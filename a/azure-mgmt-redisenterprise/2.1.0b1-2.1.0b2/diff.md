# Comparing `tmp/azure-mgmt-redisenterprise-2.1.0b1.zip` & `tmp/azure-mgmt-redisenterprise-2.1.0b2.zip`

## zipinfo {}

```diff
@@ -1,59 +1,61 @@
-Zip file size: 97419 bytes, number of entries: 57
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/azure/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/
--rw-rw-r--  2.0 unx      638 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/_meta.json
--rw-rw-r--  2.0 unx      221 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/MANIFEST.in
--rw-rw-r--  2.0 unx      973 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/CHANGELOG.md
--rw-rw-r--  2.0 unx       38 b- defN 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/setup.cfg
--rw-rw-r--  2.0 unx     2837 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/setup.py
--rw-rw-r--  2.0 unx     1384 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/README.md
--rw-rw-r--  2.0 unx     3263 b- defN 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/PKG-INFO
--rw-rw-r--  2.0 unx     1074 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/LICENSE
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/
--rw-rw-r--  2.0 unx       65 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/
--rw-rw-r--  2.0 unx       65 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/models/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/
--rw-rw-r--  2.0 unx     3770 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_configuration.py
--rw-rw-r--  2.0 unx     1530 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_patch.py
--rw-rw-r--  2.0 unx     1169 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_vendor.py
--rw-rw-r--  2.0 unx      934 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/__init__.py
--rw-rw-r--  2.0 unx     5818 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_redis_enterprise_management_client.py
--rw-rw-r--  2.0 unx      488 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_version.py
--rw-rw-r--  2.0 unx    77872 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_serialization.py
--rw-rw-r--  2.0 unx       26 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/py.typed
--rw-rw-r--  2.0 unx     4601 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/models/_redis_enterprise_management_client_enums.py
--rw-rw-r--  2.0 unx    58205 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/models/_patch.py
--rw-rw-r--  2.0 unx     4259 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/models/__init__.py
--rw-rw-r--  2.0 unx    31853 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_private_endpoint_connections_operations.py
--rw-rw-r--  2.0 unx     6273 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_operations_status_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_patch.py
--rw-rw-r--  2.0 unx    48121 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_redis_enterprise_operations.py
--rw-rw-r--  2.0 unx     1300 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/__init__.py
--rw-rw-r--  2.0 unx     8213 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_private_link_resources_operations.py
--rw-rw-r--  2.0 unx     6773 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_operations.py
--rw-rw-r--  2.0 unx   101099 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_databases_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/
--rw-rw-r--  2.0 unx     3818 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/_configuration.py
--rw-rw-r--  2.0 unx     1530 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/_patch.py
--rw-rw-r--  2.0 unx      881 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/__init__.py
--rw-rw-r--  2.0 unx     5974 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/_redis_enterprise_management_client.py
--rw-rw-r--  2.0 unx    25555 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_private_endpoint_connections_operations.py
--rw-rw-r--  2.0 unx     4939 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_operations_status_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    40526 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_redis_enterprise_operations.py
--rw-rw-r--  2.0 unx     1300 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/__init__.py
--rw-rw-r--  2.0 unx     6829 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_private_link_resources_operations.py
--rw-rw-r--  2.0 unx     6058 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_operations.py
--rw-rw-r--  2.0 unx    86068 b- defN 22-Nov-23 02:11 azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_databases_operations.py
--rw-rw-r--  2.0 unx     2225 b- defN 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/SOURCES.txt
--rw-rw-r--  2.0 unx        1 b- defN 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx        6 b- defN 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/top_level.txt
--rw-rw-r--  2.0 unx     3263 b- defN 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/PKG-INFO
--rw-rw-r--  2.0 unx        1 b- defN 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/dependency_links.txt
--rw-rw-r--  2.0 unx      116 b- defN 22-Nov-23 02:12 azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/requires.txt
-57 files, 563974 bytes uncompressed, 84231 bytes compressed:  85.1%
+Zip file size: 108533 bytes, number of entries: 59
+drwxrwxr-x  2.0 unx        0 b- stor 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/azure/
+-rw-rw-r--  2.0 unx      221 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/MANIFEST.in
+-rw-rw-r--  2.0 unx      638 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/_meta.json
+-rw-rw-r--  2.0 unx     4820 b- defN 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/PKG-INFO
+-rw-rw-r--  2.0 unx     2845 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/setup.py
+-rw-rw-r--  2.0 unx     1074 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/LICENSE
+-rw-rw-r--  2.0 unx       38 b- defN 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/setup.cfg
+-rw-rw-r--  2.0 unx     1712 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/CHANGELOG.md
+-rw-rw-r--  2.0 unx     2202 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/README.md
+-rw-rw-r--  2.0 unx     4820 b- defN 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/PKG-INFO
+-rw-rw-r--  2.0 unx        6 b- defN 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/top_level.txt
+-rw-rw-r--  2.0 unx      124 b- defN 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/requires.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/dependency_links.txt
+-rw-rw-r--  2.0 unx     2345 b- defN 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/SOURCES.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/not-zip-safe
+drwxrwxr-x  2.0 unx        0 b- stor 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/models/
+-rw-rw-r--  2.0 unx     1530 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_patch.py
+-rw-rw-r--  2.0 unx    78824 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_serialization.py
+-rw-rw-r--  2.0 unx     3794 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_configuration.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_vendor.py
+-rw-rw-r--  2.0 unx       26 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/py.typed
+-rw-rw-r--  2.0 unx     6112 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_redis_enterprise_management_client.py
+-rw-rw-r--  2.0 unx      934 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/__init__.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_version.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Apr-20 03:08 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/
+-rw-rw-r--  2.0 unx     1530 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/_patch.py
+-rw-rw-r--  2.0 unx     3842 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/_configuration.py
+-rw-rw-r--  2.0 unx     6277 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/_redis_enterprise_management_client.py
+-rw-rw-r--  2.0 unx      881 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx     6350 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_skus_operations.py
+-rw-rw-r--  2.0 unx    97863 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_databases_operations.py
+-rw-rw-r--  2.0 unx     6096 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx    25723 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_private_endpoint_connections_operations.py
+-rw-rw-r--  2.0 unx     4973 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_operations_status_operations.py
+-rw-rw-r--  2.0 unx     6867 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_private_link_resources_operations.py
+-rw-rw-r--  2.0 unx     1367 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    40772 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_redis_enterprise_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_patch.py
+-rw-rw-r--  2.0 unx     7499 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_skus_operations.py
+-rw-rw-r--  2.0 unx   114828 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_databases_operations.py
+-rw-rw-r--  2.0 unx     6841 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_operations.py
+-rw-rw-r--  2.0 unx    32141 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_private_endpoint_connections_operations.py
+-rw-rw-r--  2.0 unx     6337 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_operations_status_operations.py
+-rw-rw-r--  2.0 unx     8281 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_private_link_resources_operations.py
+-rw-rw-r--  2.0 unx     1367 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/__init__.py
+-rw-rw-r--  2.0 unx    48547 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_redis_enterprise_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/models/_patch.py
+-rw-rw-r--  2.0 unx     5388 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/models/_redis_enterprise_management_client_enums.py
+-rw-rw-r--  2.0 unx    81638 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/models/_models_py3.py
+-rw-rw-r--  2.0 unx     5521 b- defN 23-Apr-20 03:07 azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/models/__init__.py
+59 files, 636938 bytes uncompressed, 94817 bytes compressed:  85.1%
```

## zipnote {}

```diff
@@ -1,172 +1,178 @@
-Filename: azure-mgmt-redisenterprise-2.1.0b1/
+Filename: azure-mgmt-redisenterprise-2.1.0b2/
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/_meta.json
+Filename: azure-mgmt-redisenterprise-2.1.0b2/MANIFEST.in
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/MANIFEST.in
+Filename: azure-mgmt-redisenterprise-2.1.0b2/_meta.json
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/CHANGELOG.md
+Filename: azure-mgmt-redisenterprise-2.1.0b2/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/setup.cfg
+Filename: azure-mgmt-redisenterprise-2.1.0b2/setup.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/setup.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/LICENSE
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/README.md
+Filename: azure-mgmt-redisenterprise-2.1.0b2/setup.cfg
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/PKG-INFO
+Filename: azure-mgmt-redisenterprise-2.1.0b2/CHANGELOG.md
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/LICENSE
+Filename: azure-mgmt-redisenterprise-2.1.0b2/README.md
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/__init__.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/top_level.txt
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/requires.txt
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/__init__.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/dependency_links.txt
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/models/
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/SOURCES.txt
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_configuration.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/__init__.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_patch.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_vendor.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/__init__.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/__init__.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_redis_enterprise_management_client.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_version.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/models/
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_serialization.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_patch.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/py.typed
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_serialization.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/models/_redis_enterprise_management_client_enums.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/models/_models_py3.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/models/_patch.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/py.typed
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/models/__init__.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_redis_enterprise_management_client.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_private_endpoint_connections_operations.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/__init__.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_operations_status_operations.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_version.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_patch.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_redis_enterprise_operations.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/__init__.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_private_link_resources_operations.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/_redis_enterprise_management_client.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_operations.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_databases_operations.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_skus_operations.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/_configuration.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_databases_operations.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/_patch.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/__init__.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_private_endpoint_connections_operations.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/_redis_enterprise_management_client.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_operations_status_operations.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_private_endpoint_connections_operations.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_private_link_resources_operations.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_operations_status_operations.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_patch.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_redis_enterprise_operations.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_redis_enterprise_operations.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/__init__.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_skus_operations.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_private_link_resources_operations.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_databases_operations.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_operations.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_databases_operations.py
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_private_endpoint_connections_operations.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/SOURCES.txt
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_operations_status_operations.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/not-zip-safe
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_private_link_resources_operations.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/top_level.txt
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/PKG-INFO
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_redis_enterprise_operations.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/dependency_links.txt
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/requires.txt
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/models/_redis_enterprise_management_client_enums.py
+Comment: 
+
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/models/_models_py3.py
+Comment: 
+
+Filename: azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/models/__init__.py
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/setup.py` & `azure-mgmt-redisenterprise-2.1.0b2/setup.py`

 * *Files 8% similar despite different names*

```diff
@@ -66,14 +66,14 @@
         'azure.mgmt',
     ]),
     include_package_data=True,
     package_data={
         'pytyped': ['py.typed'],
     },
     install_requires=[
-        "msrest>=0.7.1",
+        "isodate<1.0.0,>=0.6.1",
         "azure-common~=1.1",
         "azure-mgmt-core>=1.3.2,<2.0.0",
         "typing-extensions>=4.3.0; python_version<'3.8.0'",
     ],
     python_requires=">=3.7"
 )
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/PKG-INFO` & `azure-mgmt-redisenterprise-2.1.0b2/PKG-INFO`

 * *Files 27% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-redisenterprise
-Version: 2.1.0b1
+Version: 2.1.0b2
 Summary: Microsoft Azure Redis Enterprise Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 4 - Beta
@@ -27,36 +27,90 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-# Usage
+## Getting started
 
+### Prerequisites
 
-To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
- 
-For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/)
-Code samples for this package can be found at [Redis Enterprise Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
-Additional code samples for different Azure services are available at [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+- Python 3.7+ is required to use this package.
+- [Azure subscription](https://azure.microsoft.com/free/)
 
+### Install the package
 
-# Provide Feedback
+```bash
+pip install azure-mgmt-redisenterprise
+pip install azure-identity
+```
+
+### Authentication
+
+By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
+
+- `AZURE_CLIENT_ID` for Azure client ID.
+- `AZURE_TENANT_ID` for Azure tenant ID.
+- `AZURE_CLIENT_SECRET` for Azure client secret.
+
+In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
+
+With above configuration, client can be authenticated by following code:
+
+```python
+from azure.identity import DefaultAzureCredential
+from azure.mgmt.redisenterprise import RedisEnterpriseManagementClient
+import os
+
+sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
+client = RedisEnterpriseManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
+```
+
+## Examples
+
+Code samples for this package can be found at:
+- [Search Redis Enterprise Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+
+
+## Troubleshooting
+
+## Next steps
+
+## Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-redisenterprise%2FREADME.png)
 
 
 # Release History
 
+## 2.1.0b2 (2023-04-20)
+
+### Features Added
+
+  - Added operation DatabasesOperations.begin_flush
+  - Added operation group SkusOperations
+  - Model Cluster has a new parameter encryption
+  - Model Cluster has a new parameter identity
+  - Model Cluster has a new parameter system_data
+  - Model ClusterUpdate has a new parameter encryption
+  - Model ClusterUpdate has a new parameter identity
+  - Model Database has a new parameter system_data
+  - Model PrivateEndpointConnection has a new parameter system_data
+  - Model PrivateLinkResource has a new parameter system_data
+  - Model ProxyResource has a new parameter system_data
+  - Model Resource has a new parameter system_data
+  - Model TrackedResource has a new parameter system_data
+
 ## 2.1.0b1 (2022-11-22)
 
 ### Other Changes
 
   - Added generated samples in github repo
   - Drop support for python<3.7.0
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/LICENSE` & `azure-mgmt-redisenterprise-2.1.0b2/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_configuration.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_configuration.py`

 * *Files 2% similar despite different names*

```diff
@@ -31,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-01-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-03-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(RedisEnterpriseManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2022-01-01"] = kwargs.pop("api_version", "2022-01-01")
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop("api_version", "2023-03-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_patch.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_vendor.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_vendor.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,16 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+from typing import List, cast
+
 from azure.core.pipeline.transport import HttpRequest
 
 
 def _convert_request(request, files=None):
     data = request.content if not files else None
     request = HttpRequest(method=request.method, url=request.url, headers=request.headers, data=data)
     if files:
@@ -18,10 +20,11 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/__init__.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_redis_enterprise_management_client.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_redis_enterprise_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,22 +18,23 @@
 from .operations import (
     DatabasesOperations,
     Operations,
     OperationsStatusOperations,
     PrivateEndpointConnectionsOperations,
     PrivateLinkResourcesOperations,
     RedisEnterpriseOperations,
+    SkusOperations,
 )
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
-class RedisEnterpriseManagementClient:  # pylint: disable=client-accepts-api-version-keyword
+class RedisEnterpriseManagementClient:  # pylint: disable=client-accepts-api-version-keyword,too-many-instance-attributes
     """REST API for managing Redis Enterprise resources in Azure.
 
     :ivar operations: Operations operations
     :vartype operations: azure.mgmt.redisenterprise.operations.Operations
     :ivar operations_status: OperationsStatusOperations operations
     :vartype operations_status: azure.mgmt.redisenterprise.operations.OperationsStatusOperations
     :ivar redis_enterprise: RedisEnterpriseOperations operations
@@ -42,22 +43,24 @@
     :vartype databases: azure.mgmt.redisenterprise.operations.DatabasesOperations
     :ivar private_endpoint_connections: PrivateEndpointConnectionsOperations operations
     :vartype private_endpoint_connections:
      azure.mgmt.redisenterprise.operations.PrivateEndpointConnectionsOperations
     :ivar private_link_resources: PrivateLinkResourcesOperations operations
     :vartype private_link_resources:
      azure.mgmt.redisenterprise.operations.PrivateLinkResourcesOperations
+    :ivar skus: SkusOperations operations
+    :vartype skus: azure.mgmt.redisenterprise.operations.SkusOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2022-01-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-03-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
         self,
@@ -65,15 +68,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = RedisEnterpriseManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.operations_status = OperationsStatusOperations(
@@ -85,14 +88,15 @@
         self.databases = DatabasesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.private_endpoint_connections = PrivateEndpointConnectionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.private_link_resources = PrivateLinkResourcesOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
+        self.skus = SkusOperations(self._client, self._config, self._serialize, self._deserialize)
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
         <HttpRequest [GET], url: 'https://www.example.org/'>
@@ -115,9 +119,9 @@
     def close(self) -> None:
         self._client.close()
 
     def __enter__(self) -> "RedisEnterpriseManagementClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details) -> None:
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/_serialization.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/_serialization.py`

 * *Files 2% similar despite different names*

```diff
@@ -34,30 +34,47 @@
 import email
 from enum import Enum
 import json
 import logging
 import re
 import sys
 import codecs
-from typing import Optional, Union, AnyStr, IO, Mapping
+from typing import (
+    Dict,
+    Any,
+    cast,
+    Optional,
+    Union,
+    AnyStr,
+    IO,
+    Mapping,
+    Callable,
+    TypeVar,
+    MutableMapping,
+    Type,
+    List,
+    Mapping,
+)
 
 try:
     from urllib import quote  # type: ignore
 except ImportError:
     from urllib.parse import quote
 import xml.etree.ElementTree as ET
 
 import isodate  # type: ignore
 
-from typing import Dict, Any, cast
-
 from azure.core.exceptions import DeserializationError, SerializationError, raise_with_traceback
+from azure.core.serialization import NULL as AzureCoreNull
 
 _BOM = codecs.BOM_UTF8.decode(encoding="utf-8")
 
+ModelType = TypeVar("ModelType", bound="Model")
+JSON = MutableMapping[str, Any]
+
 
 class RawDeserializer:
 
     # Accept "text" because we're open minded people...
     JSON_REGEXP = re.compile(r"^(application|text)/([a-z+.]+\+)?json$")
 
     # Name used in context
@@ -273,43 +290,43 @@
     serialization and deserialization.
     """
 
     _subtype_map: Dict[str, Dict[str, Any]] = {}
     _attribute_map: Dict[str, Dict[str, Any]] = {}
     _validation: Dict[str, Dict[str, Any]] = {}
 
-    def __init__(self, **kwargs):
-        self.additional_properties = {}
+    def __init__(self, **kwargs: Any) -> None:
+        self.additional_properties: Dict[str, Any] = {}
         for k in kwargs:
             if k not in self._attribute_map:
                 _LOGGER.warning("%s is not a known attribute of class %s and will be ignored", k, self.__class__)
             elif k in self._validation and self._validation[k].get("readonly", False):
                 _LOGGER.warning("Readonly attribute %s will be ignored in class %s", k, self.__class__)
             else:
                 setattr(self, k, kwargs[k])
 
-    def __eq__(self, other):
+    def __eq__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         if isinstance(other, self.__class__):
             return self.__dict__ == other.__dict__
         return False
 
-    def __ne__(self, other):
+    def __ne__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         return not self.__eq__(other)
 
-    def __str__(self):
+    def __str__(self) -> str:
         return str(self.__dict__)
 
     @classmethod
-    def enable_additional_properties_sending(cls):
+    def enable_additional_properties_sending(cls) -> None:
         cls._attribute_map["additional_properties"] = {"key": "", "type": "{object}"}
 
     @classmethod
-    def is_xml_model(cls):
+    def is_xml_model(cls) -> bool:
         try:
             cls._xml_map  # type: ignore
         except AttributeError:
             return False
         return True
 
     @classmethod
@@ -318,30 +335,35 @@
         try:
             xml_map = cls._xml_map  # type: ignore
         except AttributeError:
             xml_map = {}
 
         return _create_xml_node(xml_map.get("name", cls.__name__), xml_map.get("prefix", None), xml_map.get("ns", None))
 
-    def serialize(self, keep_readonly=False, **kwargs):
+    def serialize(self, keep_readonly: bool = False, **kwargs: Any) -> JSON:
         """Return the JSON that would be sent to azure from this model.
 
         This is an alias to `as_dict(full_restapi_key_transformer, keep_readonly=False)`.
 
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param bool keep_readonly: If you want to serialize the readonly attributes
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
         return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)
 
-    def as_dict(self, keep_readonly=True, key_transformer=attribute_transformer, **kwargs):
-        """Return a dict that can be JSONify using json.dump.
+    def as_dict(
+        self,
+        keep_readonly: bool = True,
+        key_transformer: Callable[[str, Dict[str, Any], Any], Any] = attribute_transformer,
+        **kwargs: Any
+    ) -> JSON:
+        """Return a dict that can be serialized using json.dump.
 
         Advanced usage might optionally use a callback as parameter:
 
         .. code::python
 
             def my_key_transformer(key, attr_desc, value):
                 return key
@@ -380,41 +402,46 @@
                 raise ValueError("Not Autorest generated code")
         except Exception:
             # Assume it's not Autorest generated (tests?). Add ourselves as dependencies.
             client_models = {cls.__name__: cls}
         return client_models
 
     @classmethod
-    def deserialize(cls, data, content_type=None):
+    def deserialize(cls: Type[ModelType], data: Any, content_type: Optional[str] = None) -> ModelType:
         """Parse a str using the RestAPI syntax and return a model.
 
         :param str data: A str using RestAPI structure. JSON by default.
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
         return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
-    def from_dict(cls, data, key_extractors=None, content_type=None):
+    def from_dict(
+        cls: Type[ModelType],
+        data: Any,
+        key_extractors: Optional[Callable[[str, Dict[str, Any], Any], Any]] = None,
+        content_type: Optional[str] = None,
+    ) -> ModelType:
         """Parse a dict using given key extractor return a model.
 
         By default consider key
         extractors (rest_key_case_insensitive_extractor, attribute_key_case_insensitive_extractor
         and last_rest_key_case_insensitive_extractor)
 
         :param dict data: A dict using RestAPI structure
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
-        deserializer.key_extractors = (
-            [
+        deserializer.key_extractors = (  # type: ignore
+            [  # type: ignore
                 attribute_key_case_insensitive_extractor,
                 rest_key_case_insensitive_extractor,
                 last_rest_key_case_insensitive_extractor,
             ]
             if key_extractors is None
             else key_extractors
         )
@@ -514,15 +541,15 @@
         "min_items": lambda x, y: len(x) < y,
         "max_items": lambda x, y: len(x) > y,
         "pattern": lambda x, y: not re.match(y, x, re.UNICODE),
         "unique": lambda x, y: len(x) != len(set(x)),
         "multiple": lambda x, y: x % y != 0,
     }
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
         self.serialize_type = {
             "iso-8601": Serializer.serialize_iso,
             "rfc-1123": Serializer.serialize_rfc,
             "unix-time": Serializer.serialize_unix,
             "duration": Serializer.serialize_duration,
             "date": Serializer.serialize_date,
             "time": Serializer.serialize_time,
@@ -530,15 +557,15 @@
             "long": Serializer.serialize_long,
             "bytearray": Serializer.serialize_bytearray,
             "base64": Serializer.serialize_base64,
             "object": self.serialize_object,
             "[]": self.serialize_iter,
             "{}": self.serialize_dict,
         }
-        self.dependencies = dict(classes) if classes else {}
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_transformer = full_restapi_key_transformer
         self.client_side_validation = True
 
     def _serialize(self, target_obj, data_type=None, **kwargs):
         """Serialize data into a string according to type.
 
         :param target_obj: The data to be serialized.
@@ -622,16 +649,15 @@
                         else:  # That's a basic type
                             # Integrate namespace if necessary
                             local_node = _create_xml_node(xml_name, xml_prefix, xml_ns)
                             local_node.text = unicode_str(new_attr)
                             serialized.append(local_node)  # type: ignore
                     else:  # JSON
                         for k in reversed(keys):  # type: ignore
-                            unflattened = {k: new_attr}
-                            new_attr = unflattened
+                            new_attr = {k: new_attr}
 
                         _new_attr = new_attr
                         _serialized = serialized
                         for k in keys:  # type: ignore
                             if k not in _serialized:
                                 _serialized.update(_new_attr)  # type: ignore
                             _new_attr = _new_attr[k]  # type: ignore
@@ -652,16 +678,16 @@
         :param str data_type: The type to be serialized from.
         :rtype: dict
         :raises: SerializationError if serialization fails.
         :raises: ValueError if data is None
         """
 
         # Just in case this is a dict
-        internal_data_type = data_type.strip("[]{}")
-        internal_data_type = self.dependencies.get(internal_data_type, None)
+        internal_data_type_str = data_type.strip("[]{}")
+        internal_data_type = self.dependencies.get(internal_data_type_str, None)
         try:
             is_xml_model_serialization = kwargs["is_xml"]
         except KeyError:
             if internal_data_type and issubclass(internal_data_type, Model):
                 is_xml_model_serialization = kwargs.setdefault("is_xml", internal_data_type.is_xml_model())
             else:
                 is_xml_model_serialization = False
@@ -773,14 +799,16 @@
         :raises: ValueError if data is None
         :raises: SerializationError if serialization fails.
         """
         if data is None:
             raise ValueError("No value for given attribute")
 
         try:
+            if data is AzureCoreNull:
+                return None
             if data_type in self.basic_types.values():
                 return self.serialize_basic(data, data_type, **kwargs)
 
             elif data_type in self.serialize_type:
                 return self.serialize_type[data_type](data, **kwargs)
 
             # If dependencies is empty, try with current data class
@@ -1157,15 +1185,16 @@
 
 
 def rest_key_extractor(attr, attr_desc, data):
     key = attr_desc["key"]
     working_data = data
 
     while "." in key:
-        dict_keys = _FLATTEN.split(key)
+        # Need the cast, as for some reasons "split" is typed as list[str | Any]
+        dict_keys = cast(List[str], _FLATTEN.split(key))
         if len(dict_keys) == 1:
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = working_data.get(working_key, data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
@@ -1328,15 +1357,15 @@
     :ivar list key_extractors: Ordered list of extractors to be used by this deserializer.
     """
 
     basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
     valid_date = re.compile(r"\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}" r"\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?")
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
         self.deserialize_type = {
             "iso-8601": Deserializer.deserialize_iso,
             "rfc-1123": Deserializer.deserialize_rfc,
             "unix-time": Deserializer.deserialize_unix,
             "duration": Deserializer.deserialize_duration,
             "date": Deserializer.deserialize_date,
             "time": Deserializer.deserialize_time,
@@ -1348,15 +1377,15 @@
             "[]": self.deserialize_iter,
             "{}": self.deserialize_dict,
         }
         self.deserialize_expected_types = {
             "duration": (isodate.Duration, datetime.timedelta),
             "iso-8601": (datetime.datetime),
         }
-        self.dependencies = dict(classes) if classes else {}
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_extractors = [rest_key_extractor, xml_key_extractor]
         # Additional properties only works if the "rest_key_extractor" is used to
         # extract the keys. Making it to work whatever the key extractor is too much
         # complicated, with no real scenario for now.
         # So adding a flag to disable additional properties detection. This flag should be
         # used if your expect the deserialization to NOT come from a JSON REST syntax.
         # Otherwise, result are unexpected
@@ -1467,40 +1496,40 @@
 
     def _classify_target(self, target, data):
         """Check to see whether the deserialization target object can
         be classified into a subclass.
         Once classification has been determined, initialize object.
 
         :param str target: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         """
         if target is None:
             return None, None
 
         if isinstance(target, basestring):
             try:
                 target = self.dependencies[target]
             except KeyError:
                 return target, target
 
         try:
             target = target._classify(data, self.dependencies)
         except AttributeError:
             pass  # Target is not a Model, no classify
-        return target, target.__class__.__name__
+        return target, target.__class__.__name__  # type: ignore
 
     def failsafe_deserialize(self, target_obj, data, content_type=None):
         """Ignores any errors encountered in deserialization,
         and falls back to not deserializing the object. Recommended
         for use in error deserialization, as we want to return the
         HttpResponseError to users, and not have them deal with
         a deserialization error.
 
         :param str target_obj: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         :param str content_type: Swagger "produces" if available.
         """
         try:
             return self(target_obj, data, content_type=content_type)
         except:
             _LOGGER.debug(
                 "Ran into a deserialization error. Ignoring since this is failsafe deserialization", exc_info=True
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/models/_redis_enterprise_management_client_enums.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/models/_redis_enterprise_management_client_enums.py`

 * *Files 25% similar despite different names*

```diff
@@ -33,14 +33,32 @@
 class ClusteringPolicy(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Clustering policy - default is OSSCluster. Specified at create time."""
 
     ENTERPRISE_CLUSTER = "EnterpriseCluster"
     OSS_CLUSTER = "OSSCluster"
 
 
+class CmkIdentityType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """Only userAssignedIdentity is supported in this API version; other types may be supported in the
+    future.
+    """
+
+    SYSTEM_ASSIGNED_IDENTITY = "systemAssignedIdentity"
+    USER_ASSIGNED_IDENTITY = "userAssignedIdentity"
+
+
+class CreatedByType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """The type of identity that created the resource."""
+
+    USER = "User"
+    APPLICATION = "Application"
+    MANAGED_IDENTITY = "ManagedIdentity"
+    KEY = "Key"
+
+
 class EvictionPolicy(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Redis eviction policy - default is VolatileLRU."""
 
     ALL_KEYS_LFU = "AllKeysLFU"
     ALL_KEYS_LRU = "AllKeysLRU"
     ALL_KEYS_RANDOM = "AllKeysRandom"
     VOLATILE_LRU = "VolatileLRU"
@@ -56,14 +74,25 @@
     LINKED = "Linked"
     LINKING = "Linking"
     UNLINKING = "Unlinking"
     LINK_FAILED = "LinkFailed"
     UNLINK_FAILED = "UnlinkFailed"
 
 
+class ManagedServiceIdentityType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """Type of managed service identity (where both SystemAssigned and UserAssigned types are
+    allowed).
+    """
+
+    NONE = "None"
+    SYSTEM_ASSIGNED = "SystemAssigned"
+    USER_ASSIGNED = "UserAssigned"
+    SYSTEM_ASSIGNED_USER_ASSIGNED = "SystemAssigned, UserAssigned"
+
+
 class Origin(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The intended executor of the operation; as in Resource Based Access Control (RBAC) and audit
     logs UX. Default value is "user,system".
     """
 
     USER = "user"
     SYSTEM = "system"
@@ -129,17 +158,15 @@
     ENABLE_FAILED = "EnableFailed"
     DISABLING = "Disabling"
     DISABLE_FAILED = "DisableFailed"
     DISABLED = "Disabled"
 
 
 class SkuName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """The type of RedisEnterprise cluster to deploy. Possible values: (Enterprise_E10,
-    EnterpriseFlash_F300 etc.).
-    """
+    """SkuName."""
 
     ENTERPRISE_E10 = "Enterprise_E10"
     ENTERPRISE_E20 = "Enterprise_E20"
     ENTERPRISE_E50 = "Enterprise_E50"
     ENTERPRISE_E100 = "Enterprise_E100"
     ENTERPRISE_FLASH_F300 = "EnterpriseFlash_F300"
     ENTERPRISE_FLASH_F700 = "EnterpriseFlash_F700"
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/models/_models_py3.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/models/_models_py3.py`

 * *Files 19% similar despite different names*

```diff
@@ -3,15 +3,16 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from typing import Dict, List, Optional, TYPE_CHECKING, Union
+import datetime
+from typing import Any, Dict, List, Optional, TYPE_CHECKING, Union
 
 from .. import _serialization
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
@@ -33,93 +34,131 @@
     }
 
     _attribute_map = {
         "primary_key": {"key": "primaryKey", "type": "str"},
         "secondary_key": {"key": "secondaryKey", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.primary_key = None
         self.secondary_key = None
 
 
+class Capability(_serialization.Model):
+    """Information about the features the location supports.
+
+    :ivar name: Feature name.
+    :vartype name: str
+    :ivar value: Indicates whether feature is supported or not.
+    :vartype value: bool
+    """
+
+    _attribute_map = {
+        "name": {"key": "name", "type": "str"},
+        "value": {"key": "value", "type": "bool"},
+    }
+
+    def __init__(self, *, name: Optional[str] = None, value: Optional[bool] = None, **kwargs: Any) -> None:
+        """
+        :keyword name: Feature name.
+        :paramtype name: str
+        :keyword value: Indicates whether feature is supported or not.
+        :paramtype value: bool
+        """
+        super().__init__(**kwargs)
+        self.name = name
+        self.value = value
+
+
 class Resource(_serialization.Model):
     """Common fields that are returned in the response for all Azure Resource Manager resources.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: Fully qualified resource ID for the resource. Ex -
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
+    :vartype system_data: ~azure.mgmt.redisenterprise.models.SystemData
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
+        "system_data": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
+        "system_data": {"key": "systemData", "type": "SystemData"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
         self.type = None
+        self.system_data = None
 
 
 class TrackedResource(Resource):
-    """The resource model definition for an Azure Resource Manager tracked top level resource which has 'tags' and a 'location'.
+    """The resource model definition for an Azure Resource Manager tracked top level resource which
+    has 'tags' and a 'location'.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar id: Fully qualified resource ID for the resource. Ex -
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
+    :vartype system_data: ~azure.mgmt.redisenterprise.models.SystemData
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives. Required.
     :vartype location: str
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
+        "system_data": {"readonly": True},
         "location": {"required": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
+        "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
     }
 
-    def __init__(self, *, location: str, tags: Optional[Dict[str, str]] = None, **kwargs):
+    def __init__(self, *, location: str, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         """
         super().__init__(**kwargs)
@@ -138,25 +177,32 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
+    :vartype system_data: ~azure.mgmt.redisenterprise.models.SystemData
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives. Required.
     :vartype location: str
     :ivar sku: The SKU to create, which affects price, performance, and features. Required.
     :vartype sku: ~azure.mgmt.redisenterprise.models.Sku
     :ivar zones: The Availability Zones where this cluster will be deployed.
     :vartype zones: list[str]
+    :ivar identity: The identity of the resource.
+    :vartype identity: ~azure.mgmt.redisenterprise.models.ManagedServiceIdentity
     :ivar minimum_tls_version: The minimum TLS version for the cluster to support, e.g. '1.2'.
      Known values are: "1.0", "1.1", and "1.2".
     :vartype minimum_tls_version: str or ~azure.mgmt.redisenterprise.models.TlsVersion
+    :ivar encryption: Encryption-at-rest configuration for the cluster.
+    :vartype encryption: ~azure.mgmt.redisenterprise.models.ClusterPropertiesEncryption
     :ivar host_name: DNS name of the cluster endpoint.
     :vartype host_name: str
     :ivar provisioning_state: Current provisioning status of the cluster. Known values are:
      "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
     :vartype provisioning_state: str or ~azure.mgmt.redisenterprise.models.ProvisioningState
     :ivar resource_state: Current resource status of the cluster. Known values are: "Running",
      "Creating", "CreateFailed", "Updating", "UpdateFailed", "Deleting", "DeleteFailed", "Enabling",
@@ -170,32 +216,36 @@
      list[~azure.mgmt.redisenterprise.models.PrivateEndpointConnection]
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
+        "system_data": {"readonly": True},
         "location": {"required": True},
         "sku": {"required": True},
         "host_name": {"readonly": True},
         "provisioning_state": {"readonly": True},
         "resource_state": {"readonly": True},
         "redis_version": {"readonly": True},
         "private_endpoint_connections": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
+        "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
         "sku": {"key": "sku", "type": "Sku"},
         "zones": {"key": "zones", "type": "[str]"},
+        "identity": {"key": "identity", "type": "ManagedServiceIdentity"},
         "minimum_tls_version": {"key": "properties.minimumTlsVersion", "type": "str"},
+        "encryption": {"key": "properties.encryption", "type": "ClusterPropertiesEncryption"},
         "host_name": {"key": "properties.hostName", "type": "str"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
         "resource_state": {"key": "properties.resourceState", "type": "str"},
         "redis_version": {"key": "properties.redisVersion", "type": "str"},
         "private_endpoint_connections": {
             "key": "properties.privateEndpointConnections",
             "type": "[PrivateEndpointConnection]",
@@ -205,34 +255,42 @@
     def __init__(
         self,
         *,
         location: str,
         sku: "_models.Sku",
         tags: Optional[Dict[str, str]] = None,
         zones: Optional[List[str]] = None,
+        identity: Optional["_models.ManagedServiceIdentity"] = None,
         minimum_tls_version: Optional[Union[str, "_models.TlsVersion"]] = None,
-        **kwargs
-    ):
+        encryption: Optional["_models.ClusterPropertiesEncryption"] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         :keyword sku: The SKU to create, which affects price, performance, and features. Required.
         :paramtype sku: ~azure.mgmt.redisenterprise.models.Sku
         :keyword zones: The Availability Zones where this cluster will be deployed.
         :paramtype zones: list[str]
+        :keyword identity: The identity of the resource.
+        :paramtype identity: ~azure.mgmt.redisenterprise.models.ManagedServiceIdentity
         :keyword minimum_tls_version: The minimum TLS version for the cluster to support, e.g. '1.2'.
          Known values are: "1.0", "1.1", and "1.2".
         :paramtype minimum_tls_version: str or ~azure.mgmt.redisenterprise.models.TlsVersion
+        :keyword encryption: Encryption-at-rest configuration for the cluster.
+        :paramtype encryption: ~azure.mgmt.redisenterprise.models.ClusterPropertiesEncryption
         """
         super().__init__(tags=tags, location=location, **kwargs)
         self.sku = sku
         self.zones = zones
+        self.identity = identity
         self.minimum_tls_version = minimum_tls_version
+        self.encryption = encryption
         self.host_name = None
         self.provisioning_state = None
         self.resource_state = None
         self.redis_version = None
         self.private_endpoint_connections = None
 
 
@@ -252,36 +310,159 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Cluster]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.Cluster"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.Cluster"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: List of clusters.
         :paramtype value: list[~azure.mgmt.redisenterprise.models.Cluster]
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = None
 
 
+class ClusterPropertiesEncryption(_serialization.Model):
+    """Encryption-at-rest configuration for the cluster.
+
+    :ivar customer_managed_key_encryption: All Customer-managed key encryption properties for the
+     resource. Set this to an empty object to use Microsoft-managed key encryption.
+    :vartype customer_managed_key_encryption:
+     ~azure.mgmt.redisenterprise.models.ClusterPropertiesEncryptionCustomerManagedKeyEncryption
+    """
+
+    _attribute_map = {
+        "customer_managed_key_encryption": {
+            "key": "customerManagedKeyEncryption",
+            "type": "ClusterPropertiesEncryptionCustomerManagedKeyEncryption",
+        },
+    }
+
+    def __init__(
+        self,
+        *,
+        customer_managed_key_encryption: Optional[
+            "_models.ClusterPropertiesEncryptionCustomerManagedKeyEncryption"
+        ] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword customer_managed_key_encryption: All Customer-managed key encryption properties for
+         the resource. Set this to an empty object to use Microsoft-managed key encryption.
+        :paramtype customer_managed_key_encryption:
+         ~azure.mgmt.redisenterprise.models.ClusterPropertiesEncryptionCustomerManagedKeyEncryption
+        """
+        super().__init__(**kwargs)
+        self.customer_managed_key_encryption = customer_managed_key_encryption
+
+
+class ClusterPropertiesEncryptionCustomerManagedKeyEncryption(_serialization.Model):
+    """All Customer-managed key encryption properties for the resource. Set this to an empty object to
+    use Microsoft-managed key encryption.
+
+    :ivar key_encryption_key_identity: All identity configuration for Customer-managed key settings
+     defining which identity should be used to auth to Key Vault.
+    :vartype key_encryption_key_identity:
+     ~azure.mgmt.redisenterprise.models.ClusterPropertiesEncryptionCustomerManagedKeyEncryptionKeyIdentity
+    :ivar key_encryption_key_url: Key encryption key Url, versioned only. Ex:
+     https://contosovault.vault.azure.net/keys/contosokek/562a4bb76b524a1493a6afe8e536ee78.
+    :vartype key_encryption_key_url: str
+    """
+
+    _attribute_map = {
+        "key_encryption_key_identity": {
+            "key": "keyEncryptionKeyIdentity",
+            "type": "ClusterPropertiesEncryptionCustomerManagedKeyEncryptionKeyIdentity",
+        },
+        "key_encryption_key_url": {"key": "keyEncryptionKeyUrl", "type": "str"},
+    }
+
+    def __init__(
+        self,
+        *,
+        key_encryption_key_identity: Optional[
+            "_models.ClusterPropertiesEncryptionCustomerManagedKeyEncryptionKeyIdentity"
+        ] = None,
+        key_encryption_key_url: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword key_encryption_key_identity: All identity configuration for Customer-managed key
+         settings defining which identity should be used to auth to Key Vault.
+        :paramtype key_encryption_key_identity:
+         ~azure.mgmt.redisenterprise.models.ClusterPropertiesEncryptionCustomerManagedKeyEncryptionKeyIdentity
+        :keyword key_encryption_key_url: Key encryption key Url, versioned only. Ex:
+         https://contosovault.vault.azure.net/keys/contosokek/562a4bb76b524a1493a6afe8e536ee78.
+        :paramtype key_encryption_key_url: str
+        """
+        super().__init__(**kwargs)
+        self.key_encryption_key_identity = key_encryption_key_identity
+        self.key_encryption_key_url = key_encryption_key_url
+
+
+class ClusterPropertiesEncryptionCustomerManagedKeyEncryptionKeyIdentity(_serialization.Model):
+    """All identity configuration for Customer-managed key settings defining which identity should be
+    used to auth to Key Vault.
+
+    :ivar user_assigned_identity_resource_id: User assigned identity to use for accessing key
+     encryption key Url. Ex: /subscriptions/:code:`<sub uuid>`/resourceGroups/:code:`<resource
+     group>`/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId.
+    :vartype user_assigned_identity_resource_id: str
+    :ivar identity_type: Only userAssignedIdentity is supported in this API version; other types
+     may be supported in the future. Known values are: "systemAssignedIdentity" and
+     "userAssignedIdentity".
+    :vartype identity_type: str or ~azure.mgmt.redisenterprise.models.CmkIdentityType
+    """
+
+    _attribute_map = {
+        "user_assigned_identity_resource_id": {"key": "userAssignedIdentityResourceId", "type": "str"},
+        "identity_type": {"key": "identityType", "type": "str"},
+    }
+
+    def __init__(
+        self,
+        *,
+        user_assigned_identity_resource_id: Optional[str] = None,
+        identity_type: Optional[Union[str, "_models.CmkIdentityType"]] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword user_assigned_identity_resource_id: User assigned identity to use for accessing key
+         encryption key Url. Ex: /subscriptions/:code:`<sub uuid>`/resourceGroups/:code:`<resource
+         group>`/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId.
+        :paramtype user_assigned_identity_resource_id: str
+        :keyword identity_type: Only userAssignedIdentity is supported in this API version; other types
+         may be supported in the future. Known values are: "systemAssignedIdentity" and
+         "userAssignedIdentity".
+        :paramtype identity_type: str or ~azure.mgmt.redisenterprise.models.CmkIdentityType
+        """
+        super().__init__(**kwargs)
+        self.user_assigned_identity_resource_id = user_assigned_identity_resource_id
+        self.identity_type = identity_type
+
+
 class ClusterUpdate(_serialization.Model):
     """A partial update to the RedisEnterprise cluster.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar sku: The SKU to create, which affects price, performance, and features.
     :vartype sku: ~azure.mgmt.redisenterprise.models.Sku
+    :ivar identity: The identity of the resource.
+    :vartype identity: ~azure.mgmt.redisenterprise.models.ManagedServiceIdentity
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar minimum_tls_version: The minimum TLS version for the cluster to support, e.g. '1.2'.
      Known values are: "1.0", "1.1", and "1.2".
     :vartype minimum_tls_version: str or ~azure.mgmt.redisenterprise.models.TlsVersion
+    :ivar encryption: Encryption-at-rest configuration for the cluster.
+    :vartype encryption: ~azure.mgmt.redisenterprise.models.ClusterPropertiesEncryption
     :ivar host_name: DNS name of the cluster endpoint.
     :vartype host_name: str
     :ivar provisioning_state: Current provisioning status of the cluster. Known values are:
      "Succeeded", "Failed", "Canceled", "Creating", "Updating", and "Deleting".
     :vartype provisioning_state: str or ~azure.mgmt.redisenterprise.models.ProvisioningState
     :ivar resource_state: Current resource status of the cluster. Known values are: "Running",
      "Creating", "CreateFailed", "Updating", "UpdateFailed", "Deleting", "DeleteFailed", "Enabling",
@@ -301,82 +482,98 @@
         "resource_state": {"readonly": True},
         "redis_version": {"readonly": True},
         "private_endpoint_connections": {"readonly": True},
     }
 
     _attribute_map = {
         "sku": {"key": "sku", "type": "Sku"},
+        "identity": {"key": "identity", "type": "ManagedServiceIdentity"},
         "tags": {"key": "tags", "type": "{str}"},
         "minimum_tls_version": {"key": "properties.minimumTlsVersion", "type": "str"},
+        "encryption": {"key": "properties.encryption", "type": "ClusterPropertiesEncryption"},
         "host_name": {"key": "properties.hostName", "type": "str"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
         "resource_state": {"key": "properties.resourceState", "type": "str"},
         "redis_version": {"key": "properties.redisVersion", "type": "str"},
         "private_endpoint_connections": {
             "key": "properties.privateEndpointConnections",
             "type": "[PrivateEndpointConnection]",
         },
     }
 
     def __init__(
         self,
         *,
         sku: Optional["_models.Sku"] = None,
+        identity: Optional["_models.ManagedServiceIdentity"] = None,
         tags: Optional[Dict[str, str]] = None,
         minimum_tls_version: Optional[Union[str, "_models.TlsVersion"]] = None,
-        **kwargs
-    ):
+        encryption: Optional["_models.ClusterPropertiesEncryption"] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword sku: The SKU to create, which affects price, performance, and features.
         :paramtype sku: ~azure.mgmt.redisenterprise.models.Sku
+        :keyword identity: The identity of the resource.
+        :paramtype identity: ~azure.mgmt.redisenterprise.models.ManagedServiceIdentity
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword minimum_tls_version: The minimum TLS version for the cluster to support, e.g. '1.2'.
          Known values are: "1.0", "1.1", and "1.2".
         :paramtype minimum_tls_version: str or ~azure.mgmt.redisenterprise.models.TlsVersion
+        :keyword encryption: Encryption-at-rest configuration for the cluster.
+        :paramtype encryption: ~azure.mgmt.redisenterprise.models.ClusterPropertiesEncryption
         """
         super().__init__(**kwargs)
         self.sku = sku
+        self.identity = identity
         self.tags = tags
         self.minimum_tls_version = minimum_tls_version
+        self.encryption = encryption
         self.host_name = None
         self.provisioning_state = None
         self.resource_state = None
         self.redis_version = None
         self.private_endpoint_connections = None
 
 
 class ProxyResource(Resource):
-    """The resource model definition for a Azure Resource Manager proxy resource. It will not have tags and a location.
+    """The resource model definition for a Azure Resource Manager proxy resource. It will not have
+    tags and a location.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: Fully qualified resource ID for the resource. Ex -
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
+    :vartype system_data: ~azure.mgmt.redisenterprise.models.SystemData
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
+        "system_data": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
+        "system_data": {"key": "systemData", "type": "SystemData"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
 
 
 class Database(ProxyResource):  # pylint: disable=too-many-instance-attributes
     """Describes a database on the RedisEnterprise cluster.
 
@@ -386,14 +583,17 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
+    :vartype system_data: ~azure.mgmt.redisenterprise.models.SystemData
     :ivar client_protocol: Specifies whether redis clients can connect using TLS-encrypted or
      plaintext redis protocols. Default is TLS-encrypted. Known values are: "Encrypted" and
      "Plaintext".
     :vartype client_protocol: str or ~azure.mgmt.redisenterprise.models.Protocol
     :ivar port: TCP port of the database endpoint. Specified at create time. Defaults to an
      available port.
     :vartype port: int
@@ -421,22 +621,24 @@
     :vartype geo_replication: ~azure.mgmt.redisenterprise.models.DatabasePropertiesGeoReplication
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
+        "system_data": {"readonly": True},
         "provisioning_state": {"readonly": True},
         "resource_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
+        "system_data": {"key": "systemData", "type": "SystemData"},
         "client_protocol": {"key": "properties.clientProtocol", "type": "str"},
         "port": {"key": "properties.port", "type": "int"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
         "resource_state": {"key": "properties.resourceState", "type": "str"},
         "clustering_policy": {"key": "properties.clusteringPolicy", "type": "str"},
         "eviction_policy": {"key": "properties.evictionPolicy", "type": "str"},
         "persistence": {"key": "properties.persistence", "type": "Persistence"},
@@ -450,16 +652,16 @@
         client_protocol: Optional[Union[str, "_models.Protocol"]] = None,
         port: Optional[int] = None,
         clustering_policy: Optional[Union[str, "_models.ClusteringPolicy"]] = None,
         eviction_policy: Optional[Union[str, "_models.EvictionPolicy"]] = None,
         persistence: Optional["_models.Persistence"] = None,
         modules: Optional[List["_models.Module"]] = None,
         geo_replication: Optional["_models.DatabasePropertiesGeoReplication"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword client_protocol: Specifies whether redis clients can connect using TLS-encrypted or
          plaintext redis protocols. Default is TLS-encrypted. Known values are: "Encrypted" and
          "Plaintext".
         :paramtype client_protocol: str or ~azure.mgmt.redisenterprise.models.Protocol
         :keyword port: TCP port of the database endpoint. Specified at create time. Defaults to an
          available port.
@@ -508,15 +710,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Database]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.Database"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.Database"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: List of databases.
         :paramtype value: list[~azure.mgmt.redisenterprise.models.Database]
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = None
@@ -537,16 +739,16 @@
     }
 
     def __init__(
         self,
         *,
         group_nickname: Optional[str] = None,
         linked_databases: Optional[List["_models.LinkedDatabase"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword group_nickname: Name for the group of linked database resources.
         :paramtype group_nickname: str
         :keyword linked_databases: List of database resources to link with this database.
         :paramtype linked_databases: list[~azure.mgmt.redisenterprise.models.LinkedDatabase]
         """
         super().__init__(**kwargs)
@@ -613,16 +815,16 @@
         client_protocol: Optional[Union[str, "_models.Protocol"]] = None,
         port: Optional[int] = None,
         clustering_policy: Optional[Union[str, "_models.ClusteringPolicy"]] = None,
         eviction_policy: Optional[Union[str, "_models.EvictionPolicy"]] = None,
         persistence: Optional["_models.Persistence"] = None,
         modules: Optional[List["_models.Module"]] = None,
         geo_replication: Optional["_models.DatabasePropertiesGeoReplication"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword client_protocol: Specifies whether redis clients can connect using TLS-encrypted or
          plaintext redis protocols. Default is TLS-encrypted. Known values are: "Encrypted" and
          "Plaintext".
         :paramtype client_protocol: str or ~azure.mgmt.redisenterprise.models.Protocol
         :keyword port: TCP port of the database endpoint. Specified at create time. Defaults to an
          available port.
@@ -672,15 +874,15 @@
     }
 
     _attribute_map = {
         "type": {"key": "type", "type": "str"},
         "info": {"key": "info", "type": "object"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.type = None
         self.info = None
 
 
 class ErrorDetail(_serialization.Model):
@@ -712,36 +914,37 @@
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
         "target": {"key": "target", "type": "str"},
         "details": {"key": "details", "type": "[ErrorDetail]"},
         "additional_info": {"key": "additionalInfo", "type": "[ErrorAdditionalInfo]"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.code = None
         self.message = None
         self.target = None
         self.details = None
         self.additional_info = None
 
 
 class ErrorResponse(_serialization.Model):
-    """Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response format.).
+    """Common error response for all Azure Resource Manager APIs to return error details for failed
+    operations. (This also follows the OData error response format.).
 
     :ivar error: The error object.
     :vartype error: ~azure.mgmt.redisenterprise.models.ErrorDetail
     """
 
     _attribute_map = {
         "error": {"key": "error", "type": "ErrorDetail"},
     }
 
-    def __init__(self, *, error: Optional["_models.ErrorDetail"] = None, **kwargs):
+    def __init__(self, *, error: Optional["_models.ErrorDetail"] = None, **kwargs: Any) -> None:
         """
         :keyword error: The error object.
         :paramtype error: ~azure.mgmt.redisenterprise.models.ErrorDetail
         """
         super().__init__(**kwargs)
         self.error = error
 
@@ -759,23 +962,45 @@
         "sas_uri": {"required": True},
     }
 
     _attribute_map = {
         "sas_uri": {"key": "sasUri", "type": "str"},
     }
 
-    def __init__(self, *, sas_uri: str, **kwargs):
+    def __init__(self, *, sas_uri: str, **kwargs: Any) -> None:
         """
         :keyword sas_uri: SAS URI for the target directory to export to. Required.
         :paramtype sas_uri: str
         """
         super().__init__(**kwargs)
         self.sas_uri = sas_uri
 
 
+class FlushParameters(_serialization.Model):
+    """Parameters for a Redis Enterprise active geo-replication flush operation.
+
+    :ivar ids: The resource identifiers of all the other database resources in the georeplication
+     group to be flushed.
+    :vartype ids: list[str]
+    """
+
+    _attribute_map = {
+        "ids": {"key": "ids", "type": "[str]"},
+    }
+
+    def __init__(self, *, ids: Optional[List[str]] = None, **kwargs: Any) -> None:
+        """
+        :keyword ids: The resource identifiers of all the other database resources in the
+         georeplication group to be flushed.
+        :paramtype ids: list[str]
+        """
+        super().__init__(**kwargs)
+        self.ids = ids
+
+
 class ForceUnlinkParameters(_serialization.Model):
     """Parameters for a Redis Enterprise Active Geo Replication Force Unlink operation.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar ids: The resource IDs of the database resources to be unlinked. Required.
     :vartype ids: list[str]
@@ -785,15 +1010,15 @@
         "ids": {"required": True},
     }
 
     _attribute_map = {
         "ids": {"key": "ids", "type": "[str]"},
     }
 
-    def __init__(self, *, ids: List[str], **kwargs):
+    def __init__(self, *, ids: List[str], **kwargs: Any) -> None:
         """
         :keyword ids: The resource IDs of the database resources to be unlinked. Required.
         :paramtype ids: list[str]
         """
         super().__init__(**kwargs)
         self.ids = ids
 
@@ -811,15 +1036,15 @@
         "sas_uris": {"required": True},
     }
 
     _attribute_map = {
         "sas_uris": {"key": "sasUris", "type": "[str]"},
     }
 
-    def __init__(self, *, sas_uris: List[str], **kwargs):
+    def __init__(self, *, sas_uris: List[str], **kwargs: Any) -> None:
         """
         :keyword sas_uris: SAS URIs for the target blobs to import from. Required.
         :paramtype sas_uris: list[str]
         """
         super().__init__(**kwargs)
         self.sas_uris = sas_uris
 
@@ -841,24 +1066,120 @@
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "state": {"key": "state", "type": "str"},
     }
 
-    def __init__(self, *, id: Optional[str] = None, **kwargs):  # pylint: disable=redefined-builtin
+    def __init__(self, *, id: Optional[str] = None, **kwargs: Any) -> None:  # pylint: disable=redefined-builtin
         """
         :keyword id: Resource ID of a database resource to link with this database.
         :paramtype id: str
         """
         super().__init__(**kwargs)
         self.id = id
         self.state = None
 
 
+class LocationInfo(_serialization.Model):
+    """Information about location (for example: features that it supports).
+
+    :ivar location: Location name.
+    :vartype location: str
+    :ivar capabilities: List of capabilities.
+    :vartype capabilities: list[~azure.mgmt.redisenterprise.models.Capability]
+    """
+
+    _attribute_map = {
+        "location": {"key": "location", "type": "str"},
+        "capabilities": {"key": "capabilities", "type": "[Capability]"},
+    }
+
+    def __init__(
+        self,
+        *,
+        location: Optional[str] = None,
+        capabilities: Optional[List["_models.Capability"]] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword location: Location name.
+        :paramtype location: str
+        :keyword capabilities: List of capabilities.
+        :paramtype capabilities: list[~azure.mgmt.redisenterprise.models.Capability]
+        """
+        super().__init__(**kwargs)
+        self.location = location
+        self.capabilities = capabilities
+
+
+class ManagedServiceIdentity(_serialization.Model):
+    """Managed service identity (system assigned and/or user assigned identities).
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar principal_id: The service principal ID of the system assigned identity. This property
+     will only be provided for a system assigned identity.
+    :vartype principal_id: str
+    :ivar tenant_id: The tenant ID of the system assigned identity. This property will only be
+     provided for a system assigned identity.
+    :vartype tenant_id: str
+    :ivar type: Type of managed service identity (where both SystemAssigned and UserAssigned types
+     are allowed). Required. Known values are: "None", "SystemAssigned", "UserAssigned", and
+     "SystemAssigned, UserAssigned".
+    :vartype type: str or ~azure.mgmt.redisenterprise.models.ManagedServiceIdentityType
+    :ivar user_assigned_identities: The set of user assigned identities associated with the
+     resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form:
+     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
+     The dictionary values can be empty objects ({}) in requests.
+    :vartype user_assigned_identities: dict[str,
+     ~azure.mgmt.redisenterprise.models.UserAssignedIdentity]
+    """
+
+    _validation = {
+        "principal_id": {"readonly": True},
+        "tenant_id": {"readonly": True},
+        "type": {"required": True},
+    }
+
+    _attribute_map = {
+        "principal_id": {"key": "principalId", "type": "str"},
+        "tenant_id": {"key": "tenantId", "type": "str"},
+        "type": {"key": "type", "type": "str"},
+        "user_assigned_identities": {"key": "userAssignedIdentities", "type": "{UserAssignedIdentity}"},
+    }
+
+    def __init__(
+        self,
+        *,
+        type: Union[str, "_models.ManagedServiceIdentityType"],
+        user_assigned_identities: Optional[Dict[str, "_models.UserAssignedIdentity"]] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword type: Type of managed service identity (where both SystemAssigned and UserAssigned
+         types are allowed). Required. Known values are: "None", "SystemAssigned", "UserAssigned", and
+         "SystemAssigned, UserAssigned".
+        :paramtype type: str or ~azure.mgmt.redisenterprise.models.ManagedServiceIdentityType
+        :keyword user_assigned_identities: The set of user assigned identities associated with the
+         resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form:
+         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
+         The dictionary values can be empty objects ({}) in requests.
+        :paramtype user_assigned_identities: dict[str,
+         ~azure.mgmt.redisenterprise.models.UserAssignedIdentity]
+        """
+        super().__init__(**kwargs)
+        self.principal_id = None
+        self.tenant_id = None
+        self.type = type
+        self.user_assigned_identities = user_assigned_identities
+
+
 class Module(_serialization.Model):
     """Specifies configuration of a redis module.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
@@ -878,15 +1199,15 @@
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "args": {"key": "args", "type": "str"},
         "version": {"key": "version", "type": "str"},
     }
 
-    def __init__(self, *, name: str, args: Optional[str] = None, **kwargs):
+    def __init__(self, *, name: str, args: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword name: The name of the module, e.g. 'RedisBloom', 'RediSearch', 'RedisTimeSeries'.
          Required.
         :paramtype name: str
         :keyword args: Configuration options for the module, e.g. 'ERROR_RATE 0.01 INITIAL_SIZE 400'.
         :paramtype args: str
         """
@@ -929,15 +1250,15 @@
         "name": {"key": "name", "type": "str"},
         "is_data_action": {"key": "isDataAction", "type": "bool"},
         "display": {"key": "display", "type": "OperationDisplay"},
         "origin": {"key": "origin", "type": "str"},
         "action_type": {"key": "actionType", "type": "str"},
     }
 
-    def __init__(self, *, display: Optional["_models.OperationDisplay"] = None, **kwargs):
+    def __init__(self, *, display: Optional["_models.OperationDisplay"] = None, **kwargs: Any) -> None:
         """
         :keyword display: Localized display information for this particular operation.
         :paramtype display: ~azure.mgmt.redisenterprise.models.OperationDisplay
         """
         super().__init__(**kwargs)
         self.name = None
         self.is_data_action = None
@@ -975,25 +1296,26 @@
     _attribute_map = {
         "provider": {"key": "provider", "type": "str"},
         "resource": {"key": "resource", "type": "str"},
         "operation": {"key": "operation", "type": "str"},
         "description": {"key": "description", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.provider = None
         self.resource = None
         self.operation = None
         self.description = None
 
 
 class OperationListResult(_serialization.Model):
-    """A list of REST API operations supported by an Azure Resource Provider. It contains an URL link to get the next set of results.
+    """A list of REST API operations supported by an Azure Resource Provider. It contains an URL link
+    to get the next set of results.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: List of operations supported by the resource provider.
     :vartype value: list[~azure.mgmt.redisenterprise.models.Operation]
     :ivar next_link: URL to get the next set of operation list results (if there are any).
     :vartype next_link: str
@@ -1005,15 +1327,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Operation]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class OperationStatus(_serialization.Model):
@@ -1047,16 +1369,16 @@
         *,
         id: Optional[str] = None,  # pylint: disable=redefined-builtin
         name: Optional[str] = None,
         start_time: Optional[str] = None,
         end_time: Optional[str] = None,
         status: Optional[str] = None,
         error: Optional["_models.ErrorResponse"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: The operation's unique id.
         :paramtype id: str
         :keyword name: The operation's name.
         :paramtype name: str
         :keyword start_time: The start time of the operation.
         :paramtype start_time: str
@@ -1101,16 +1423,16 @@
     def __init__(
         self,
         *,
         aof_enabled: Optional[bool] = None,
         rdb_enabled: Optional[bool] = None,
         aof_frequency: Optional[Union[str, "_models.AofFrequency"]] = None,
         rdb_frequency: Optional[Union[str, "_models.RdbFrequency"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword aof_enabled: Sets whether AOF is enabled.
         :paramtype aof_enabled: bool
         :keyword rdb_enabled: Sets whether RDB is enabled.
         :paramtype rdb_enabled: bool
         :keyword aof_frequency: Sets the frequency at which data is written to disk. Known values are:
          "1s" and "always".
@@ -1139,15 +1461,15 @@
         "id": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
 
 
 class PrivateEndpointConnection(Resource):
     """The Private Endpoint Connection resource.
@@ -1158,14 +1480,17 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
+    :vartype system_data: ~azure.mgmt.redisenterprise.models.SystemData
     :ivar private_endpoint: The resource of private end point.
     :vartype private_endpoint: ~azure.mgmt.redisenterprise.models.PrivateEndpoint
     :ivar private_link_service_connection_state: A collection of information about the state of the
      connection between service consumer and provider.
     :vartype private_link_service_connection_state:
      ~azure.mgmt.redisenterprise.models.PrivateLinkServiceConnectionState
     :ivar provisioning_state: The provisioning state of the private endpoint connection resource.
@@ -1174,36 +1499,38 @@
      ~azure.mgmt.redisenterprise.models.PrivateEndpointConnectionProvisioningState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
+        "system_data": {"readonly": True},
         "provisioning_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
+        "system_data": {"key": "systemData", "type": "SystemData"},
         "private_endpoint": {"key": "properties.privateEndpoint", "type": "PrivateEndpoint"},
         "private_link_service_connection_state": {
             "key": "properties.privateLinkServiceConnectionState",
             "type": "PrivateLinkServiceConnectionState",
         },
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         private_endpoint: Optional["_models.PrivateEndpoint"] = None,
         private_link_service_connection_state: Optional["_models.PrivateLinkServiceConnectionState"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword private_endpoint: The resource of private end point.
         :paramtype private_endpoint: ~azure.mgmt.redisenterprise.models.PrivateEndpoint
         :keyword private_link_service_connection_state: A collection of information about the state of
          the connection between service consumer and provider.
         :paramtype private_link_service_connection_state:
          ~azure.mgmt.redisenterprise.models.PrivateLinkServiceConnectionState
@@ -1221,15 +1548,15 @@
     :vartype value: list[~azure.mgmt.redisenterprise.models.PrivateEndpointConnection]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[PrivateEndpointConnection]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.PrivateEndpointConnection"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.PrivateEndpointConnection"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: Array of private endpoint connections.
         :paramtype value: list[~azure.mgmt.redisenterprise.models.PrivateEndpointConnection]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -1243,40 +1570,45 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
+    :vartype system_data: ~azure.mgmt.redisenterprise.models.SystemData
     :ivar group_id: The private link resource group id.
     :vartype group_id: str
     :ivar required_members: The private link resource required member names.
     :vartype required_members: list[str]
     :ivar required_zone_names: The private link resource Private link DNS zone name.
     :vartype required_zone_names: list[str]
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
+        "system_data": {"readonly": True},
         "group_id": {"readonly": True},
         "required_members": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
+        "system_data": {"key": "systemData", "type": "SystemData"},
         "group_id": {"key": "properties.groupId", "type": "str"},
         "required_members": {"key": "properties.requiredMembers", "type": "[str]"},
         "required_zone_names": {"key": "properties.requiredZoneNames", "type": "[str]"},
     }
 
-    def __init__(self, *, required_zone_names: Optional[List[str]] = None, **kwargs):
+    def __init__(self, *, required_zone_names: Optional[List[str]] = None, **kwargs: Any) -> None:
         """
         :keyword required_zone_names: The private link resource Private link DNS zone name.
         :paramtype required_zone_names: list[str]
         """
         super().__init__(**kwargs)
         self.group_id = None
         self.required_members = None
@@ -1290,25 +1622,26 @@
     :vartype value: list[~azure.mgmt.redisenterprise.models.PrivateLinkResource]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[PrivateLinkResource]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.PrivateLinkResource"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.PrivateLinkResource"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: Array of private link resources.
         :paramtype value: list[~azure.mgmt.redisenterprise.models.PrivateLinkResource]
         """
         super().__init__(**kwargs)
         self.value = value
 
 
 class PrivateLinkServiceConnectionState(_serialization.Model):
-    """A collection of information about the state of the connection between service consumer and provider.
+    """A collection of information about the state of the connection between service consumer and
+    provider.
 
     :ivar status: Indicates whether the connection has been Approved/Rejected/Removed by the owner
      of the service. Known values are: "Pending", "Approved", and "Rejected".
     :vartype status: str or
      ~azure.mgmt.redisenterprise.models.PrivateEndpointServiceConnectionStatus
     :ivar description: The reason for approval/rejection of the connection.
     :vartype description: str
@@ -1325,16 +1658,16 @@
 
     def __init__(
         self,
         *,
         status: Optional[Union[str, "_models.PrivateEndpointServiceConnectionStatus"]] = None,
         description: Optional[str] = None,
         actions_required: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: Indicates whether the connection has been Approved/Rejected/Removed by the
          owner of the service. Known values are: "Pending", "Approved", and "Rejected".
         :paramtype status: str or
          ~azure.mgmt.redisenterprise.models.PrivateEndpointServiceConnectionStatus
         :keyword description: The reason for approval/rejection of the connection.
         :paramtype description: str
@@ -1362,24 +1695,84 @@
         "key_type": {"required": True},
     }
 
     _attribute_map = {
         "key_type": {"key": "keyType", "type": "str"},
     }
 
-    def __init__(self, *, key_type: Union[str, "_models.AccessKeyType"], **kwargs):
+    def __init__(self, *, key_type: Union[str, "_models.AccessKeyType"], **kwargs: Any) -> None:
         """
         :keyword key_type: Which access key to regenerate. Required. Known values are: "Primary" and
          "Secondary".
         :paramtype key_type: str or ~azure.mgmt.redisenterprise.models.AccessKeyType
         """
         super().__init__(**kwargs)
         self.key_type = key_type
 
 
+class RegionSkuDetail(_serialization.Model):
+    """Details about the location requested and the available skus in the location.
+
+    :ivar resource_type: Resource type which has the SKU, such as Microsoft.Cache/redisEnterprise.
+    :vartype resource_type: str
+    :ivar location_info: Details about location and its capabilities.
+    :vartype location_info: ~azure.mgmt.redisenterprise.models.LocationInfo
+    :ivar sku_details: Details about available skus.
+    :vartype sku_details: ~azure.mgmt.redisenterprise.models.SkuDetail
+    """
+
+    _attribute_map = {
+        "resource_type": {"key": "resourceType", "type": "str"},
+        "location_info": {"key": "locationInfo", "type": "LocationInfo"},
+        "sku_details": {"key": "skuDetails", "type": "SkuDetail"},
+    }
+
+    def __init__(
+        self,
+        *,
+        resource_type: Optional[str] = None,
+        location_info: Optional["_models.LocationInfo"] = None,
+        sku_details: Optional["_models.SkuDetail"] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword resource_type: Resource type which has the SKU, such as
+         Microsoft.Cache/redisEnterprise.
+        :paramtype resource_type: str
+        :keyword location_info: Details about location and its capabilities.
+        :paramtype location_info: ~azure.mgmt.redisenterprise.models.LocationInfo
+        :keyword sku_details: Details about available skus.
+        :paramtype sku_details: ~azure.mgmt.redisenterprise.models.SkuDetail
+        """
+        super().__init__(**kwargs)
+        self.resource_type = resource_type
+        self.location_info = location_info
+        self.sku_details = sku_details
+
+
+class RegionSkuDetails(_serialization.Model):
+    """List of details about all the available SKUs.
+
+    :ivar value: List of Sku Detail.
+    :vartype value: list[~azure.mgmt.redisenterprise.models.RegionSkuDetail]
+    """
+
+    _attribute_map = {
+        "value": {"key": "value", "type": "[RegionSkuDetail]"},
+    }
+
+    def __init__(self, *, value: Optional[List["_models.RegionSkuDetail"]] = None, **kwargs: Any) -> None:
+        """
+        :keyword value: List of Sku Detail.
+        :paramtype value: list[~azure.mgmt.redisenterprise.models.RegionSkuDetail]
+        """
+        super().__init__(**kwargs)
+        self.value = value
+
+
 class Sku(_serialization.Model):
     """SKU parameters supplied to the create RedisEnterprise operation.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar name: The type of RedisEnterprise cluster to deploy. Possible values: (Enterprise_E10,
      EnterpriseFlash_F300 etc.). Required. Known values are: "Enterprise_E10", "Enterprise_E20",
@@ -1396,21 +1789,139 @@
     }
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "capacity": {"key": "capacity", "type": "int"},
     }
 
-    def __init__(self, *, name: Union[str, "_models.SkuName"], capacity: Optional[int] = None, **kwargs):
+    def __init__(self, *, name: Union[str, "_models.SkuName"], capacity: Optional[int] = None, **kwargs: Any) -> None:
         """
         :keyword name: The type of RedisEnterprise cluster to deploy. Possible values: (Enterprise_E10,
          EnterpriseFlash_F300 etc.). Required. Known values are: "Enterprise_E10", "Enterprise_E20",
          "Enterprise_E50", "Enterprise_E100", "EnterpriseFlash_F300", "EnterpriseFlash_F700", and
          "EnterpriseFlash_F1500".
         :paramtype name: str or ~azure.mgmt.redisenterprise.models.SkuName
         :keyword capacity: The size of the RedisEnterprise cluster. Defaults to 2 or 3 depending on
          SKU. Valid values are (2, 4, 6, ...) for Enterprise SKUs and (3, 9, 15, ...) for Flash SKUs.
         :paramtype capacity: int
         """
         super().__init__(**kwargs)
         self.name = name
         self.capacity = capacity
+
+
+class SkuDetail(_serialization.Model):
+    """Information about Sku.
+
+    :ivar name: The type of RedisEnterprise cluster to deploy. Possible values: (Enterprise_E10,
+     EnterpriseFlash_F300 etc.). Known values are: "Enterprise_E10", "Enterprise_E20",
+     "Enterprise_E50", "Enterprise_E100", "EnterpriseFlash_F300", "EnterpriseFlash_F700", and
+     "EnterpriseFlash_F1500".
+    :vartype name: str or ~azure.mgmt.redisenterprise.models.SkuName
+    """
+
+    _attribute_map = {
+        "name": {"key": "name", "type": "str"},
+    }
+
+    def __init__(self, *, name: Optional[Union[str, "_models.SkuName"]] = None, **kwargs: Any) -> None:
+        """
+        :keyword name: The type of RedisEnterprise cluster to deploy. Possible values: (Enterprise_E10,
+         EnterpriseFlash_F300 etc.). Known values are: "Enterprise_E10", "Enterprise_E20",
+         "Enterprise_E50", "Enterprise_E100", "EnterpriseFlash_F300", "EnterpriseFlash_F700", and
+         "EnterpriseFlash_F1500".
+        :paramtype name: str or ~azure.mgmt.redisenterprise.models.SkuName
+        """
+        super().__init__(**kwargs)
+        self.name = name
+
+
+class SystemData(_serialization.Model):
+    """Metadata pertaining to creation and last modification of the resource.
+
+    :ivar created_by: The identity that created the resource.
+    :vartype created_by: str
+    :ivar created_by_type: The type of identity that created the resource. Known values are:
+     "User", "Application", "ManagedIdentity", and "Key".
+    :vartype created_by_type: str or ~azure.mgmt.redisenterprise.models.CreatedByType
+    :ivar created_at: The timestamp of resource creation (UTC).
+    :vartype created_at: ~datetime.datetime
+    :ivar last_modified_by: The identity that last modified the resource.
+    :vartype last_modified_by: str
+    :ivar last_modified_by_type: The type of identity that last modified the resource. Known values
+     are: "User", "Application", "ManagedIdentity", and "Key".
+    :vartype last_modified_by_type: str or ~azure.mgmt.redisenterprise.models.CreatedByType
+    :ivar last_modified_at: The timestamp of resource last modification (UTC).
+    :vartype last_modified_at: ~datetime.datetime
+    """
+
+    _attribute_map = {
+        "created_by": {"key": "createdBy", "type": "str"},
+        "created_by_type": {"key": "createdByType", "type": "str"},
+        "created_at": {"key": "createdAt", "type": "iso-8601"},
+        "last_modified_by": {"key": "lastModifiedBy", "type": "str"},
+        "last_modified_by_type": {"key": "lastModifiedByType", "type": "str"},
+        "last_modified_at": {"key": "lastModifiedAt", "type": "iso-8601"},
+    }
+
+    def __init__(
+        self,
+        *,
+        created_by: Optional[str] = None,
+        created_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
+        created_at: Optional[datetime.datetime] = None,
+        last_modified_by: Optional[str] = None,
+        last_modified_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
+        last_modified_at: Optional[datetime.datetime] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword created_by: The identity that created the resource.
+        :paramtype created_by: str
+        :keyword created_by_type: The type of identity that created the resource. Known values are:
+         "User", "Application", "ManagedIdentity", and "Key".
+        :paramtype created_by_type: str or ~azure.mgmt.redisenterprise.models.CreatedByType
+        :keyword created_at: The timestamp of resource creation (UTC).
+        :paramtype created_at: ~datetime.datetime
+        :keyword last_modified_by: The identity that last modified the resource.
+        :paramtype last_modified_by: str
+        :keyword last_modified_by_type: The type of identity that last modified the resource. Known
+         values are: "User", "Application", "ManagedIdentity", and "Key".
+        :paramtype last_modified_by_type: str or ~azure.mgmt.redisenterprise.models.CreatedByType
+        :keyword last_modified_at: The timestamp of resource last modification (UTC).
+        :paramtype last_modified_at: ~datetime.datetime
+        """
+        super().__init__(**kwargs)
+        self.created_by = created_by
+        self.created_by_type = created_by_type
+        self.created_at = created_at
+        self.last_modified_by = last_modified_by
+        self.last_modified_by_type = last_modified_by_type
+        self.last_modified_at = last_modified_at
+
+
+class UserAssignedIdentity(_serialization.Model):
+    """User assigned identity properties.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar principal_id: The principal ID of the assigned identity.
+    :vartype principal_id: str
+    :ivar client_id: The client ID of the assigned identity.
+    :vartype client_id: str
+    """
+
+    _validation = {
+        "principal_id": {"readonly": True},
+        "client_id": {"readonly": True},
+    }
+
+    _attribute_map = {
+        "principal_id": {"key": "principalId", "type": "str"},
+        "client_id": {"key": "clientId", "type": "str"},
+    }
+
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
+        super().__init__(**kwargs)
+        self.principal_id = None
+        self.client_id = None
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/models/_patch.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/models/__init__.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/models/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,52 +3,67 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._models_py3 import AccessKeys
+from ._models_py3 import Capability
 from ._models_py3 import Cluster
 from ._models_py3 import ClusterList
+from ._models_py3 import ClusterPropertiesEncryption
+from ._models_py3 import ClusterPropertiesEncryptionCustomerManagedKeyEncryption
+from ._models_py3 import ClusterPropertiesEncryptionCustomerManagedKeyEncryptionKeyIdentity
 from ._models_py3 import ClusterUpdate
 from ._models_py3 import Database
 from ._models_py3 import DatabaseList
 from ._models_py3 import DatabasePropertiesGeoReplication
 from ._models_py3 import DatabaseUpdate
 from ._models_py3 import ErrorAdditionalInfo
 from ._models_py3 import ErrorDetail
 from ._models_py3 import ErrorResponse
 from ._models_py3 import ExportClusterParameters
+from ._models_py3 import FlushParameters
 from ._models_py3 import ForceUnlinkParameters
 from ._models_py3 import ImportClusterParameters
 from ._models_py3 import LinkedDatabase
+from ._models_py3 import LocationInfo
+from ._models_py3 import ManagedServiceIdentity
 from ._models_py3 import Module
 from ._models_py3 import Operation
 from ._models_py3 import OperationDisplay
 from ._models_py3 import OperationListResult
 from ._models_py3 import OperationStatus
 from ._models_py3 import Persistence
 from ._models_py3 import PrivateEndpoint
 from ._models_py3 import PrivateEndpointConnection
 from ._models_py3 import PrivateEndpointConnectionListResult
 from ._models_py3 import PrivateLinkResource
 from ._models_py3 import PrivateLinkResourceListResult
 from ._models_py3 import PrivateLinkServiceConnectionState
 from ._models_py3 import ProxyResource
 from ._models_py3 import RegenerateKeyParameters
+from ._models_py3 import RegionSkuDetail
+from ._models_py3 import RegionSkuDetails
 from ._models_py3 import Resource
 from ._models_py3 import Sku
+from ._models_py3 import SkuDetail
+from ._models_py3 import SystemData
 from ._models_py3 import TrackedResource
+from ._models_py3 import UserAssignedIdentity
 
 from ._redis_enterprise_management_client_enums import AccessKeyType
 from ._redis_enterprise_management_client_enums import ActionType
 from ._redis_enterprise_management_client_enums import AofFrequency
 from ._redis_enterprise_management_client_enums import ClusteringPolicy
+from ._redis_enterprise_management_client_enums import CmkIdentityType
+from ._redis_enterprise_management_client_enums import CreatedByType
 from ._redis_enterprise_management_client_enums import EvictionPolicy
 from ._redis_enterprise_management_client_enums import LinkState
+from ._redis_enterprise_management_client_enums import ManagedServiceIdentityType
 from ._redis_enterprise_management_client_enums import Origin
 from ._redis_enterprise_management_client_enums import PrivateEndpointConnectionProvisioningState
 from ._redis_enterprise_management_client_enums import PrivateEndpointServiceConnectionStatus
 from ._redis_enterprise_management_client_enums import Protocol
 from ._redis_enterprise_management_client_enums import ProvisioningState
 from ._redis_enterprise_management_client_enums import RdbFrequency
 from ._redis_enterprise_management_client_enums import ResourceState
@@ -56,51 +71,66 @@
 from ._redis_enterprise_management_client_enums import TlsVersion
 from ._patch import __all__ as _patch_all
 from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "AccessKeys",
+    "Capability",
     "Cluster",
     "ClusterList",
+    "ClusterPropertiesEncryption",
+    "ClusterPropertiesEncryptionCustomerManagedKeyEncryption",
+    "ClusterPropertiesEncryptionCustomerManagedKeyEncryptionKeyIdentity",
     "ClusterUpdate",
     "Database",
     "DatabaseList",
     "DatabasePropertiesGeoReplication",
     "DatabaseUpdate",
     "ErrorAdditionalInfo",
     "ErrorDetail",
     "ErrorResponse",
     "ExportClusterParameters",
+    "FlushParameters",
     "ForceUnlinkParameters",
     "ImportClusterParameters",
     "LinkedDatabase",
+    "LocationInfo",
+    "ManagedServiceIdentity",
     "Module",
     "Operation",
     "OperationDisplay",
     "OperationListResult",
     "OperationStatus",
     "Persistence",
     "PrivateEndpoint",
     "PrivateEndpointConnection",
     "PrivateEndpointConnectionListResult",
     "PrivateLinkResource",
     "PrivateLinkResourceListResult",
     "PrivateLinkServiceConnectionState",
     "ProxyResource",
     "RegenerateKeyParameters",
+    "RegionSkuDetail",
+    "RegionSkuDetails",
     "Resource",
     "Sku",
+    "SkuDetail",
+    "SystemData",
     "TrackedResource",
+    "UserAssignedIdentity",
     "AccessKeyType",
     "ActionType",
     "AofFrequency",
     "ClusteringPolicy",
+    "CmkIdentityType",
+    "CreatedByType",
     "EvictionPolicy",
     "LinkState",
+    "ManagedServiceIdentityType",
     "Origin",
     "PrivateEndpointConnectionProvisioningState",
     "PrivateEndpointServiceConnectionStatus",
     "Protocol",
     "ProvisioningState",
     "RdbFrequency",
     "ResourceState",
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_private_endpoint_connections_operations.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_private_endpoint_connections_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -43,15 +43,17 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/privateEndpointConnections",
     )  # pylint: disable=line-too-long
@@ -80,15 +82,17 @@
     private_endpoint_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/privateEndpointConnections/{privateEndpointConnectionName}",
     )  # pylint: disable=line-too-long
@@ -120,15 +124,17 @@
     private_endpoint_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/privateEndpointConnections/{privateEndpointConnectionName}",
@@ -163,15 +169,17 @@
     private_endpoint_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/privateEndpointConnections/{privateEndpointConnectionName}",
     )  # pylint: disable=line-too-long
@@ -233,15 +241,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.redisenterprise.models.PrivateEndpointConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.PrivateEndpointConnectionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -289,16 +297,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -337,15 +346,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -355,16 +364,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -396,15 +406,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -426,16 +436,17 @@
             template_url=self._put_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -552,16 +563,16 @@
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection associated
          with the Azure resource. Required.
         :type private_endpoint_connection_name: str
-        :param properties: The private endpoint connection properties. Is either a model type or a IO
-         type. Required.
+        :param properties: The private endpoint connection properties. Is either a
+         PrivateEndpointConnection type or a IO type. Required.
         :type properties: ~azure.mgmt.redisenterprise.models.PrivateEndpointConnection or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -575,15 +586,15 @@
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.PrivateEndpointConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
@@ -653,15 +664,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -671,16 +682,17 @@
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_operations_status_operations.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_operations_status_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -39,15 +39,17 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(location: str, operation_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Cache/locations/{location}/operationsStatus/{operationId}",
     )  # pylint: disable=line-too-long
@@ -107,15 +109,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
         request = build_get_request(
             location=location,
             operation_id=operation_id,
@@ -124,16 +126,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_patch.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_redis_enterprise_operations.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_redis_enterprise_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -45,15 +45,17 @@
 
 def build_create_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}",
@@ -81,15 +83,17 @@
 
 def build_update_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}",
@@ -117,15 +121,17 @@
 
 def build_delete_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}",
     )  # pylint: disable=line-too-long
@@ -148,15 +154,17 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}",
     )  # pylint: disable=line-too-long
@@ -179,15 +187,17 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise",
     )  # pylint: disable=line-too-long
@@ -209,15 +219,17 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Cache/redisEnterprise")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
@@ -262,15 +274,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -291,16 +303,17 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -399,15 +412,15 @@
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param parameters: Parameters supplied to the Create RedisEnterprise operation. Is either a
-         model type or a IO type. Required.
+         Cluster type or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.Cluster or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -419,15 +432,15 @@
         :return: An instance of LROPoller that returns either Cluster or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
@@ -482,15 +495,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.Cluster]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -511,16 +524,17 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -617,15 +631,15 @@
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param parameters: Parameters supplied to the Update RedisEnterprise operation. Is either a
-         model type or a IO type. Required.
+         ClusterUpdate type or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.ClusterUpdate or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -637,15 +651,15 @@
         :return: An instance of LROPoller that returns either Cluster or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
@@ -700,15 +714,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -717,16 +731,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -759,15 +774,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
@@ -828,15 +843,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -845,16 +860,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -882,15 +898,15 @@
         :return: An iterator like instance of either Cluster or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.redisenterprise.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.ClusterList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -937,16 +953,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -967,15 +984,15 @@
         :return: An iterator like instance of either Cluster or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.redisenterprise.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.ClusterList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -1021,16 +1038,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/__init__.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -8,22 +8,24 @@
 
 from ._operations import Operations
 from ._operations_status_operations import OperationsStatusOperations
 from ._redis_enterprise_operations import RedisEnterpriseOperations
 from ._databases_operations import DatabasesOperations
 from ._private_endpoint_connections_operations import PrivateEndpointConnectionsOperations
 from ._private_link_resources_operations import PrivateLinkResourcesOperations
+from ._skus_operations import SkusOperations
 
 from ._patch import __all__ as _patch_all
 from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Operations",
     "OperationsStatusOperations",
     "RedisEnterpriseOperations",
     "DatabasesOperations",
     "PrivateEndpointConnectionsOperations",
     "PrivateLinkResourcesOperations",
+    "SkusOperations",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_private_link_resources_operations.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_private_link_resources_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -43,15 +43,17 @@
 
 def build_list_by_cluster_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/privateLinkResources",
     )  # pylint: disable=line-too-long
@@ -108,15 +110,15 @@
         :return: An iterator like instance of either PrivateLinkResource or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.redisenterprise.models.PrivateLinkResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.PrivateLinkResourceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -164,16 +166,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_operations.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -41,15 +41,17 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Cache/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -87,15 +89,15 @@
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.redisenterprise.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -140,16 +142,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/operations/_databases_operations.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_databases_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,446 +3,99 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 import sys
-from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
+from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
-from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
-from azure.core.polling import LROPoller, NoPolling, PollingMethod
+from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
+from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.arm_polling import ARMPolling
+from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
-from .. import models as _models
-from .._serialization import Serializer
-from .._vendor import _convert_request, _format_url_section
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._databases_operations import (
+    build_create_request,
+    build_delete_request,
+    build_export_request,
+    build_flush_request,
+    build_force_unlink_request,
+    build_get_request,
+    build_import_request,
+    build_list_by_cluster_request,
+    build_list_keys_request,
+    build_regenerate_key_request,
+    build_update_request,
+)
 
 if sys.version_info >= (3, 8):
     from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
 else:
     from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_list_by_cluster_request(
-    resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_create_request(
-    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_update_request(
-    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_get_request(
-    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_delete_request(
-    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_list_keys_request(
-    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/listKeys",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_regenerate_key_request(
-    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/regenerateKey",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_import_method_request(
-    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/import",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_export_request(
-    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/export",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_force_unlink_request(
-    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2022-01-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-01-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/forceUnlink",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DatabasesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.redisenterprise.RedisEnterpriseManagementClient`'s
+        :class:`~azure.mgmt.redisenterprise.aio.RedisEnterpriseManagementClient`'s
         :attr:`databases` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list_by_cluster(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
-    ) -> Iterable["_models.Database"]:
+    ) -> AsyncIterable["_models.Database"]:
         """Gets all databases in the specified RedisEnterprise cluster.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Database or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.redisenterprise.models.Database]
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.redisenterprise.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.DatabaseList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -480,43 +133,44 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        def extract_data(pipeline_response):
+        async def extract_data(pipeline_response):
             deserialized = self._deserialize("DatabaseList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+            return deserialized.next_link or None, AsyncList(list_of_elem)
 
-        def get_next(next_link=None):
+        async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return ItemPaged(get_next, extract_data)
+        return AsyncItemPaged(get_next, extract_data)
 
     list_by_cluster.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases"
     }
 
-    def _create_initial(
+    async def _create_initial(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.Database, IO],
         **kwargs: Any
     ) -> _models.Database:
@@ -527,15 +181,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -557,16 +211,17 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -584,24 +239,24 @@
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}"
     }
 
     @overload
-    def begin_create(
+    async def begin_create(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: _models.Database,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.Database]:
+    ) -> AsyncLROPoller[_models.Database]:
         """Creates a database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -610,36 +265,37 @@
         :param parameters: Parameters supplied to the create or update database operation. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.Database
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either Database or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.Database]
+        :return: An instance of AsyncLROPoller that returns either Database or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_create(
+    async def begin_create(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.Database]:
+    ) -> AsyncLROPoller[_models.Database]:
         """Creates a database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -648,74 +304,76 @@
         :param parameters: Parameters supplied to the create or update database operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either Database or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.Database]
+        :return: An instance of AsyncLROPoller that returns either Database or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace
-    def begin_create(
+    @distributed_trace_async
+    async def begin_create(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.Database, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.Database]:
+    ) -> AsyncLROPoller[_models.Database]:
         """Creates a database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database. Required.
         :type database_name: str
         :param parameters: Parameters supplied to the create or update database operation. Is either a
-         model type or a IO type. Required.
+         Database type or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.Database or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either Database or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.Database]
+        :return: An instance of AsyncLROPoller that returns either Database or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._create_initial(
+            raw_result = await self._create_initial(
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
                 database_name=database_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
@@ -728,35 +386,36 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Database", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "original-uri"}, **kwargs)
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod,
+                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "original-uri"}, **kwargs),
             )
         elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller.from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}"
     }
 
-    def _update_initial(
+    async def _update_initial(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.DatabaseUpdate, IO],
         **kwargs: Any
     ) -> Optional[_models.Database]:
@@ -767,15 +426,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.Database]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -797,16 +456,17 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -822,24 +482,24 @@
         return deserialized
 
     _update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}"
     }
 
     @overload
-    def begin_update(
+    async def begin_update(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: _models.DatabaseUpdate,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.Database]:
+    ) -> AsyncLROPoller[_models.Database]:
         """Updates a database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -848,36 +508,37 @@
         :param parameters: Parameters supplied to the create or update database operation. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.DatabaseUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either Database or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.Database]
+        :return: An instance of AsyncLROPoller that returns either Database or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_update(
+    async def begin_update(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.Database]:
+    ) -> AsyncLROPoller[_models.Database]:
         """Updates a database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -886,74 +547,76 @@
         :param parameters: Parameters supplied to the create or update database operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either Database or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.Database]
+        :return: An instance of AsyncLROPoller that returns either Database or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace
-    def begin_update(
+    @distributed_trace_async
+    async def begin_update(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.DatabaseUpdate, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.Database]:
+    ) -> AsyncLROPoller[_models.Database]:
         """Updates a database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database. Required.
         :type database_name: str
         :param parameters: Parameters supplied to the create or update database operation. Is either a
-         model type or a IO type. Required.
+         DatabaseUpdate type or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.DatabaseUpdate or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either Database or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.Database]
+        :return: An instance of AsyncLROPoller that returns either Database or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._update_initial(
+            raw_result = await self._update_initial(
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
                 database_name=database_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
@@ -966,36 +629,39 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Database", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod,
+                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller.from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}"
     }
 
-    @distributed_trace
-    def get(self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any) -> _models.Database:
+    @distributed_trace_async
+    async def get(
+        self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
+    ) -> _models.Database:
         """Gets information about a database in a RedisEnterprise cluster.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1013,15 +679,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1031,16 +697,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1053,29 +720,29 @@
 
         return deserialized
 
     get.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}"
     }
 
-    def _delete_initial(  # pylint: disable=inconsistent-return-statements
+    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1085,16 +752,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1103,51 +771,51 @@
         if cls:
             return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}"
     }
 
-    @distributed_trace
-    def begin_delete(
+    @distributed_trace_async
+    async def begin_delete(
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
-    ) -> LROPoller[None]:
+    ) -> AsyncLROPoller[None]:
         """Deletes a single database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database. Required.
         :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._delete_initial(  # type: ignore
+            raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
                 database_name=database_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -1156,36 +824,37 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod,
+                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller.from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}"
     }
 
-    @distributed_trace
-    def list_keys(
+    @distributed_trace_async
+    async def list_keys(
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
     ) -> _models.AccessKeys:
         """Retrieves the access keys for the RedisEnterprise database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
@@ -1205,15 +874,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.AccessKeys] = kwargs.pop("cls", None)
 
         request = build_list_keys_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1223,16 +892,17 @@
             template_url=self.list_keys.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1245,15 +915,15 @@
 
         return deserialized
 
     list_keys.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/listKeys"
     }
 
-    def _regenerate_key_initial(
+    async def _regenerate_key_initial(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.RegenerateKeyParameters, IO],
         **kwargs: Any
     ) -> Optional[_models.AccessKeys]:
@@ -1264,15 +934,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.AccessKeys]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -1294,16 +964,17 @@
             template_url=self._regenerate_key_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1319,24 +990,24 @@
         return deserialized
 
     _regenerate_key_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/regenerateKey"
     }
 
     @overload
-    def begin_regenerate_key(
+    async def begin_regenerate_key(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: _models.RegenerateKeyParameters,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.AccessKeys]:
+    ) -> AsyncLROPoller[_models.AccessKeys]:
         """Regenerates the RedisEnterprise database's access keys.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1345,36 +1016,37 @@
         :param parameters: Specifies which key to regenerate. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.RegenerateKeyParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either AccessKeys or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.AccessKeys]
+        :return: An instance of AsyncLROPoller that returns either AccessKeys or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.AccessKeys]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_regenerate_key(
+    async def begin_regenerate_key(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.AccessKeys]:
+    ) -> AsyncLROPoller[_models.AccessKeys]:
         """Regenerates the RedisEnterprise database's access keys.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1383,74 +1055,76 @@
         :param parameters: Specifies which key to regenerate. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either AccessKeys or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.AccessKeys]
+        :return: An instance of AsyncLROPoller that returns either AccessKeys or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.AccessKeys]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace
-    def begin_regenerate_key(
+    @distributed_trace_async
+    async def begin_regenerate_key(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.RegenerateKeyParameters, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.AccessKeys]:
+    ) -> AsyncLROPoller[_models.AccessKeys]:
         """Regenerates the RedisEnterprise database's access keys.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database. Required.
         :type database_name: str
-        :param parameters: Specifies which key to regenerate. Is either a model type or a IO type.
-         Required.
+        :param parameters: Specifies which key to regenerate. Is either a RegenerateKeyParameters type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.RegenerateKeyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either AccessKeys or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.AccessKeys]
+        :return: An instance of AsyncLROPoller that returns either AccessKeys or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.AccessKeys]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessKeys] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._regenerate_key_initial(
+            raw_result = await self._regenerate_key_initial(
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
                 database_name=database_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
@@ -1463,35 +1137,35 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("AccessKeys", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller.from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_regenerate_key.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/regenerateKey"
     }
 
-    def _import_method_initial(  # pylint: disable=inconsistent-return-statements
+    async def _import_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.ImportClusterParameters, IO],
         **kwargs: Any
     ) -> None:
@@ -1502,73 +1176,74 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ImportClusterParameters")
 
-        request = build_import_method_request(
+        request = build_import_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._import_method_initial.metadata["url"],
+            template_url=self._import_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    _import_method_initial.metadata = {
+    _import_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/import"
     }
 
     @overload
-    def begin_import_method(
+    async def begin_import_method(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: _models.ImportClusterParameters,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[None]:
+    ) -> AsyncLROPoller[None]:
         """Imports database files to target database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1577,36 +1252,36 @@
         :param parameters: Storage information for importing into the cluster. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.ImportClusterParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_import_method(
+    async def begin_import_method(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[None]:
+    ) -> AsyncLROPoller[None]:
         """Imports database files to target database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1615,74 +1290,74 @@
         :param parameters: Storage information for importing into the cluster. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace
-    def begin_import_method(
+    @distributed_trace_async
+    async def begin_import_method(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.ImportClusterParameters, IO],
         **kwargs: Any
-    ) -> LROPoller[None]:
+    ) -> AsyncLROPoller[None]:
         """Imports database files to target database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database. Required.
         :type database_name: str
-        :param parameters: Storage information for importing into the cluster. Is either a model type
-         or a IO type. Required.
+        :param parameters: Storage information for importing into the cluster. Is either a
+         ImportClusterParameters type or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.ImportClusterParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._import_method_initial(  # type: ignore
+            raw_result = await self._import_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
                 database_name=database_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
@@ -1693,35 +1368,36 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod,
+                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller.from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_import_method.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/import"
     }
 
-    def _export_initial(  # pylint: disable=inconsistent-return-statements
+    async def _export_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.ExportClusterParameters, IO],
         **kwargs: Any
     ) -> None:
@@ -1732,15 +1408,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -1762,16 +1438,17 @@
             template_url=self._export_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1781,24 +1458,24 @@
             return cls(pipeline_response, None, {})
 
     _export_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/export"
     }
 
     @overload
-    def begin_export(
+    async def begin_export(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: _models.ExportClusterParameters,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[None]:
+    ) -> AsyncLROPoller[None]:
         """Exports a database file from target database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1807,36 +1484,36 @@
         :param parameters: Storage information for exporting into the cluster. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.ExportClusterParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_export(
+    async def begin_export(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[None]:
+    ) -> AsyncLROPoller[None]:
         """Exports a database file from target database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1845,74 +1522,74 @@
         :param parameters: Storage information for exporting into the cluster. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace
-    def begin_export(
+    @distributed_trace_async
+    async def begin_export(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.ExportClusterParameters, IO],
         **kwargs: Any
-    ) -> LROPoller[None]:
+    ) -> AsyncLROPoller[None]:
         """Exports a database file from target database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database. Required.
         :type database_name: str
-        :param parameters: Storage information for exporting into the cluster. Is either a model type
-         or a IO type. Required.
+        :param parameters: Storage information for exporting into the cluster. Is either a
+         ExportClusterParameters type or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.ExportClusterParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._export_initial(  # type: ignore
+            raw_result = await self._export_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
                 database_name=database_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
@@ -1923,35 +1600,36 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod,
+                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller.from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_export.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/export"
     }
 
-    def _force_unlink_initial(  # pylint: disable=inconsistent-return-statements
+    async def _force_unlink_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.ForceUnlinkParameters, IO],
         **kwargs: Any
     ) -> None:
@@ -1962,15 +1640,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -1992,16 +1670,17 @@
             template_url=self._force_unlink_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -2011,24 +1690,24 @@
             return cls(pipeline_response, None, {})
 
     _force_unlink_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/forceUnlink"
     }
 
     @overload
-    def begin_force_unlink(
+    async def begin_force_unlink(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: _models.ForceUnlinkParameters,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[None]:
+    ) -> AsyncLROPoller[None]:
         """Forcibly removes the link to the specified database resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -2037,36 +1716,36 @@
         :param parameters: Information identifying the database to be unlinked. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.ForceUnlinkParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_force_unlink(
+    async def begin_force_unlink(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[None]:
+    ) -> AsyncLROPoller[None]:
         """Forcibly removes the link to the specified database resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -2075,74 +1754,74 @@
         :param parameters: Information identifying the database to be unlinked. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace
-    def begin_force_unlink(
+    @distributed_trace_async
+    async def begin_force_unlink(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.ForceUnlinkParameters, IO],
         **kwargs: Any
-    ) -> LROPoller[None]:
+    ) -> AsyncLROPoller[None]:
         """Forcibly removes the link to the specified database resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database. Required.
         :type database_name: str
-        :param parameters: Information identifying the database to be unlinked. Is either a model type
-         or a IO type. Required.
+        :param parameters: Information identifying the database to be unlinked. Is either a
+         ForceUnlinkParameters type or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.ForceUnlinkParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._force_unlink_initial(  # type: ignore
+            raw_result = await self._force_unlink_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
                 database_name=database_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
@@ -2153,26 +1832,265 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod,
+                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller.from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_force_unlink.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/forceUnlink"
     }
+
+    async def _flush_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        database_name: str,
+        parameters: Union[_models.FlushParameters, IO],
+        **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(parameters, (IO, bytes)):
+            _content = parameters
+        else:
+            _json = self._serialize.body(parameters, "FlushParameters")
+
+        request = build_flush_request(
+            resource_group_name=resource_group_name,
+            cluster_name=cluster_name,
+            database_name=database_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._flush_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200, 202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _flush_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/flush"
+    }
+
+    @overload
+    async def begin_flush(
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        database_name: str,
+        parameters: _models.FlushParameters,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Flushes all the keys in this database and also from its linked databases.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param cluster_name: The name of the RedisEnterprise cluster. Required.
+        :type cluster_name: str
+        :param database_name: The name of the database. Required.
+        :type database_name: str
+        :param parameters: Information identifying the databases to be flushed. Required.
+        :type parameters: ~azure.mgmt.redisenterprise.models.FlushParameters
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    async def begin_flush(
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        database_name: str,
+        parameters: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Flushes all the keys in this database and also from its linked databases.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param cluster_name: The name of the RedisEnterprise cluster. Required.
+        :type cluster_name: str
+        :param database_name: The name of the database. Required.
+        :type database_name: str
+        :param parameters: Information identifying the databases to be flushed. Required.
+        :type parameters: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace_async
+    async def begin_flush(
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        database_name: str,
+        parameters: Union[_models.FlushParameters, IO],
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Flushes all the keys in this database and also from its linked databases.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param cluster_name: The name of the RedisEnterprise cluster. Required.
+        :type cluster_name: str
+        :param database_name: The name of the database. Required.
+        :type database_name: str
+        :param parameters: Information identifying the databases to be flushed. Is either a
+         FlushParameters type or a IO type. Required.
+        :type parameters: ~azure.mgmt.redisenterprise.models.FlushParameters or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._flush_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                cluster_name=cluster_name,
+                database_name=database_name,
+                parameters=parameters,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_flush.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/flush"
+    }
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/_configuration.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/_configuration.py`

 * *Files 4% similar despite different names*

```diff
@@ -31,22 +31,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-01-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-03-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(RedisEnterpriseManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2022-01-01"] = kwargs.pop("api_version", "2022-01-01")
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop("api_version", "2023-03-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/_patch.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/__init__.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/_redis_enterprise_management_client.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/_redis_enterprise_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,22 +18,23 @@
 from .operations import (
     DatabasesOperations,
     Operations,
     OperationsStatusOperations,
     PrivateEndpointConnectionsOperations,
     PrivateLinkResourcesOperations,
     RedisEnterpriseOperations,
+    SkusOperations,
 )
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
-class RedisEnterpriseManagementClient:  # pylint: disable=client-accepts-api-version-keyword
+class RedisEnterpriseManagementClient:  # pylint: disable=client-accepts-api-version-keyword,too-many-instance-attributes
     """REST API for managing Redis Enterprise resources in Azure.
 
     :ivar operations: Operations operations
     :vartype operations: azure.mgmt.redisenterprise.aio.operations.Operations
     :ivar operations_status: OperationsStatusOperations operations
     :vartype operations_status:
      azure.mgmt.redisenterprise.aio.operations.OperationsStatusOperations
@@ -43,22 +44,24 @@
     :vartype databases: azure.mgmt.redisenterprise.aio.operations.DatabasesOperations
     :ivar private_endpoint_connections: PrivateEndpointConnectionsOperations operations
     :vartype private_endpoint_connections:
      azure.mgmt.redisenterprise.aio.operations.PrivateEndpointConnectionsOperations
     :ivar private_link_resources: PrivateLinkResourcesOperations operations
     :vartype private_link_resources:
      azure.mgmt.redisenterprise.aio.operations.PrivateLinkResourcesOperations
+    :ivar skus: SkusOperations operations
+    :vartype skus: azure.mgmt.redisenterprise.aio.operations.SkusOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2022-01-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-03-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
         self,
@@ -66,15 +69,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = RedisEnterpriseManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.operations_status = OperationsStatusOperations(
@@ -86,14 +89,15 @@
         self.databases = DatabasesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.private_endpoint_connections = PrivateEndpointConnectionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.private_link_resources = PrivateLinkResourcesOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
+        self.skus = SkusOperations(self._client, self._config, self._serialize, self._deserialize)
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
         <HttpRequest [GET], url: 'https://www.example.org/'>
@@ -116,9 +120,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "RedisEnterpriseManagementClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details) -> None:
+    async def __aexit__(self, *exc_details: Any) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_private_endpoint_connections_operations.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_private_endpoint_connections_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -82,15 +82,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.redisenterprise.models.PrivateEndpointConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.PrivateEndpointConnectionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -138,16 +138,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -186,15 +187,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -204,16 +205,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -245,15 +247,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -275,16 +277,17 @@
             template_url=self._put_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -401,16 +404,16 @@
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection associated
          with the Azure resource. Required.
         :type private_endpoint_connection_name: str
-        :param properties: The private endpoint connection properties. Is either a model type or a IO
-         type. Required.
+        :param properties: The private endpoint connection properties. Is either a
+         PrivateEndpointConnection type or a IO type. Required.
         :type properties: ~azure.mgmt.redisenterprise.models.PrivateEndpointConnection or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -424,15 +427,15 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.PrivateEndpointConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
@@ -502,15 +505,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -520,16 +523,17 @@
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_operations_status_operations.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_operations_status_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -75,15 +75,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
         request = build_get_request(
             location=location,
             operation_id=operation_id,
@@ -92,16 +92,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_patch.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_redis_enterprise_operations.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_redis_enterprise_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -77,15 +77,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -106,16 +106,17 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -216,15 +217,15 @@
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param parameters: Parameters supplied to the Create RedisEnterprise operation. Is either a
-         model type or a IO type. Required.
+         Cluster type or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.Cluster or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -237,15 +238,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
@@ -301,15 +302,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.Cluster]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -330,16 +331,17 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -438,15 +440,15 @@
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param parameters: Parameters supplied to the Update RedisEnterprise operation. Is either a
-         model type or a IO type. Required.
+         ClusterUpdate type or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.ClusterUpdate or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -459,15 +461,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
@@ -523,15 +525,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -540,16 +542,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -582,15 +585,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
@@ -652,15 +655,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -669,16 +672,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -706,15 +710,15 @@
         :return: An iterator like instance of either Cluster or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.redisenterprise.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.ClusterList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -761,16 +765,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -791,15 +796,15 @@
         :return: An iterator like instance of either Cluster or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.redisenterprise.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.ClusterList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -845,16 +850,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/__init__.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -8,22 +8,24 @@
 
 from ._operations import Operations
 from ._operations_status_operations import OperationsStatusOperations
 from ._redis_enterprise_operations import RedisEnterpriseOperations
 from ._databases_operations import DatabasesOperations
 from ._private_endpoint_connections_operations import PrivateEndpointConnectionsOperations
 from ._private_link_resources_operations import PrivateLinkResourcesOperations
+from ._skus_operations import SkusOperations
 
 from ._patch import __all__ as _patch_all
 from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Operations",
     "OperationsStatusOperations",
     "RedisEnterpriseOperations",
     "DatabasesOperations",
     "PrivateEndpointConnectionsOperations",
     "PrivateLinkResourcesOperations",
+    "SkusOperations",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_private_link_resources_operations.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_private_link_resources_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -73,15 +73,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.redisenterprise.models.PrivateLinkResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.PrivateLinkResourceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -129,16 +129,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_operations.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/aio/operations/_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -65,15 +65,15 @@
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.redisenterprise.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -118,16 +118,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure/mgmt/redisenterprise/aio/operations/_databases_operations.py` & `azure-mgmt-redisenterprise-2.1.0b2/azure/mgmt/redisenterprise/operations/_databases_operations.py`

 * *Files 24% similar despite different names*

```diff
@@ -3,98 +3,505 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 import sys
-from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
+from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
-from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
+from azure.core.pipeline.transport import HttpResponse
+from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
+from azure.mgmt.core.polling.arm_polling import ARMPolling
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._databases_operations import (
-    build_create_request,
-    build_delete_request,
-    build_export_request,
-    build_force_unlink_request,
-    build_get_request,
-    build_import_method_request,
-    build_list_by_cluster_request,
-    build_list_keys_request,
-    build_regenerate_key_request,
-    build_update_request,
-)
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request, _format_url_section
 
 if sys.version_info >= (3, 8):
     from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
 else:
     from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_list_by_cluster_request(
+    resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_create_request(
+    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_update_request(
+    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_get_request(
+    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_delete_request(
+    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_keys_request(
+    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/listKeys",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_regenerate_key_request(
+    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/regenerateKey",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_import_request(
+    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/import",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_export_request(
+    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/export",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_force_unlink_request(
+    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/forceUnlink",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_flush_request(
+    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+        "api_version", _params.pop("api-version", "2023-03-01-preview")
+    )
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/flush",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class DatabasesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.redisenterprise.aio.RedisEnterpriseManagementClient`'s
+        :class:`~azure.mgmt.redisenterprise.RedisEnterpriseManagementClient`'s
         :attr:`databases` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list_by_cluster(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
-    ) -> AsyncIterable["_models.Database"]:
+    ) -> Iterable["_models.Database"]:
         """Gets all databases in the specified RedisEnterprise cluster.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Database or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.redisenterprise.models.Database]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.redisenterprise.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.DatabaseList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -132,43 +539,44 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
+        def extract_data(pipeline_response):
             deserialized = self._deserialize("DatabaseList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
     list_by_cluster.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases"
     }
 
-    async def _create_initial(
+    def _create_initial(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.Database, IO],
         **kwargs: Any
     ) -> _models.Database:
@@ -179,15 +587,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -209,16 +617,17 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -236,24 +645,24 @@
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}"
     }
 
     @overload
-    async def begin_create(
+    def begin_create(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: _models.Database,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Database]:
+    ) -> LROPoller[_models.Database]:
         """Creates a database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -262,37 +671,36 @@
         :param parameters: Parameters supplied to the create or update database operation. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.Database
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either Database or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.Database]
+        :return: An instance of LROPoller that returns either Database or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_create(
+    def begin_create(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Database]:
+    ) -> LROPoller[_models.Database]:
         """Creates a database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -301,76 +709,74 @@
         :param parameters: Parameters supplied to the create or update database operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either Database or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.Database]
+        :return: An instance of LROPoller that returns either Database or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_create(
+    @distributed_trace
+    def begin_create(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.Database, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Database]:
+    ) -> LROPoller[_models.Database]:
         """Creates a database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database. Required.
         :type database_name: str
         :param parameters: Parameters supplied to the create or update database operation. Is either a
-         model type or a IO type. Required.
+         Database type or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.Database or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either Database or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.Database]
+        :return: An instance of LROPoller that returns either Database or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._create_initial(
+            raw_result = self._create_initial(
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
                 database_name=database_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
@@ -383,36 +789,35 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Database", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "original-uri"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "original-uri"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}"
     }
 
-    async def _update_initial(
+    def _update_initial(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.DatabaseUpdate, IO],
         **kwargs: Any
     ) -> Optional[_models.Database]:
@@ -423,15 +828,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.Database]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -453,16 +858,17 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -478,24 +884,24 @@
         return deserialized
 
     _update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}"
     }
 
     @overload
-    async def begin_update(
+    def begin_update(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: _models.DatabaseUpdate,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Database]:
+    ) -> LROPoller[_models.Database]:
         """Updates a database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -504,37 +910,36 @@
         :param parameters: Parameters supplied to the create or update database operation. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.DatabaseUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either Database or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.Database]
+        :return: An instance of LROPoller that returns either Database or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update(
+    def begin_update(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Database]:
+    ) -> LROPoller[_models.Database]:
         """Updates a database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -543,76 +948,74 @@
         :param parameters: Parameters supplied to the create or update database operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either Database or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.Database]
+        :return: An instance of LROPoller that returns either Database or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_update(
+    @distributed_trace
+    def begin_update(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.DatabaseUpdate, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Database]:
+    ) -> LROPoller[_models.Database]:
         """Updates a database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database. Required.
         :type database_name: str
         :param parameters: Parameters supplied to the create or update database operation. Is either a
-         model type or a IO type. Required.
+         DatabaseUpdate type or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.DatabaseUpdate or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either Database or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.Database]
+        :return: An instance of LROPoller that returns either Database or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_initial(
+            raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
                 database_name=database_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
@@ -625,39 +1028,36 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Database", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}"
     }
 
-    @distributed_trace_async
-    async def get(
-        self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
-    ) -> _models.Database:
+    @distributed_trace
+    def get(self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any) -> _models.Database:
         """Gets information about a database in a RedisEnterprise cluster.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -675,15 +1075,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -693,16 +1093,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -715,29 +1116,29 @@
 
         return deserialized
 
     get.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}"
     }
 
-    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
+    def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -747,16 +1148,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -765,51 +1167,51 @@
         if cls:
             return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}"
     }
 
-    @distributed_trace_async
-    async def begin_delete(
+    @distributed_trace
+    def begin_delete(
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Deletes a single database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database. Required.
         :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._delete_initial(  # type: ignore
+            raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
                 database_name=database_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
@@ -818,37 +1220,36 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}"
     }
 
-    @distributed_trace_async
-    async def list_keys(
+    @distributed_trace
+    def list_keys(
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
     ) -> _models.AccessKeys:
         """Retrieves the access keys for the RedisEnterprise database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
@@ -868,15 +1269,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         cls: ClsType[_models.AccessKeys] = kwargs.pop("cls", None)
 
         request = build_list_keys_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -886,16 +1287,17 @@
             template_url=self.list_keys.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -908,15 +1310,15 @@
 
         return deserialized
 
     list_keys.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/listKeys"
     }
 
-    async def _regenerate_key_initial(
+    def _regenerate_key_initial(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.RegenerateKeyParameters, IO],
         **kwargs: Any
     ) -> Optional[_models.AccessKeys]:
@@ -927,15 +1329,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.AccessKeys]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -957,16 +1359,17 @@
             template_url=self._regenerate_key_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -982,24 +1385,24 @@
         return deserialized
 
     _regenerate_key_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/regenerateKey"
     }
 
     @overload
-    async def begin_regenerate_key(
+    def begin_regenerate_key(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: _models.RegenerateKeyParameters,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.AccessKeys]:
+    ) -> LROPoller[_models.AccessKeys]:
         """Regenerates the RedisEnterprise database's access keys.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1008,37 +1411,36 @@
         :param parameters: Specifies which key to regenerate. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.RegenerateKeyParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either AccessKeys or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.AccessKeys]
+        :return: An instance of LROPoller that returns either AccessKeys or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.AccessKeys]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_regenerate_key(
+    def begin_regenerate_key(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.AccessKeys]:
+    ) -> LROPoller[_models.AccessKeys]:
         """Regenerates the RedisEnterprise database's access keys.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1047,76 +1449,74 @@
         :param parameters: Specifies which key to regenerate. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either AccessKeys or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.AccessKeys]
+        :return: An instance of LROPoller that returns either AccessKeys or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.AccessKeys]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_regenerate_key(
+    @distributed_trace
+    def begin_regenerate_key(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.RegenerateKeyParameters, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.AccessKeys]:
+    ) -> LROPoller[_models.AccessKeys]:
         """Regenerates the RedisEnterprise database's access keys.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database. Required.
         :type database_name: str
-        :param parameters: Specifies which key to regenerate. Is either a model type or a IO type.
-         Required.
+        :param parameters: Specifies which key to regenerate. Is either a RegenerateKeyParameters type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.RegenerateKeyParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either AccessKeys or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.redisenterprise.models.AccessKeys]
+        :return: An instance of LROPoller that returns either AccessKeys or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.redisenterprise.models.AccessKeys]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessKeys] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._regenerate_key_initial(
+            raw_result = self._regenerate_key_initial(
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
                 database_name=database_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
@@ -1129,36 +1529,35 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("AccessKeys", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_regenerate_key.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/regenerateKey"
     }
 
-    async def _import_method_initial(  # pylint: disable=inconsistent-return-statements
+    def _import_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.ImportClusterParameters, IO],
         **kwargs: Any
     ) -> None:
@@ -1169,73 +1568,74 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(parameters, (IO, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ImportClusterParameters")
 
-        request = build_import_method_request(
+        request = build_import_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._import_method_initial.metadata["url"],
+            template_url=self._import_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
-    _import_method_initial.metadata = {
+    _import_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/import"
     }
 
     @overload
-    async def begin_import_method(
+    def begin_import_method(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: _models.ImportClusterParameters,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Imports database files to target database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1244,36 +1644,36 @@
         :param parameters: Storage information for importing into the cluster. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.ImportClusterParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_import_method(
+    def begin_import_method(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Imports database files to target database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1282,74 +1682,74 @@
         :param parameters: Storage information for importing into the cluster. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_import_method(
+    @distributed_trace
+    def begin_import_method(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.ImportClusterParameters, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Imports database files to target database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database. Required.
         :type database_name: str
-        :param parameters: Storage information for importing into the cluster. Is either a model type
-         or a IO type. Required.
+        :param parameters: Storage information for importing into the cluster. Is either a
+         ImportClusterParameters type or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.ImportClusterParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._import_method_initial(  # type: ignore
+            raw_result = self._import_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
                 database_name=database_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
@@ -1360,36 +1760,35 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_import_method.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/import"
     }
 
-    async def _export_initial(  # pylint: disable=inconsistent-return-statements
+    def _export_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.ExportClusterParameters, IO],
         **kwargs: Any
     ) -> None:
@@ -1400,15 +1799,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -1430,16 +1829,17 @@
             template_url=self._export_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1449,24 +1849,24 @@
             return cls(pipeline_response, None, {})
 
     _export_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/export"
     }
 
     @overload
-    async def begin_export(
+    def begin_export(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: _models.ExportClusterParameters,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Exports a database file from target database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1475,36 +1875,36 @@
         :param parameters: Storage information for exporting into the cluster. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.ExportClusterParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_export(
+    def begin_export(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Exports a database file from target database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1513,74 +1913,74 @@
         :param parameters: Storage information for exporting into the cluster. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_export(
+    @distributed_trace
+    def begin_export(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.ExportClusterParameters, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Exports a database file from target database.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database. Required.
         :type database_name: str
-        :param parameters: Storage information for exporting into the cluster. Is either a model type
-         or a IO type. Required.
+        :param parameters: Storage information for exporting into the cluster. Is either a
+         ExportClusterParameters type or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.ExportClusterParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._export_initial(  # type: ignore
+            raw_result = self._export_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
                 database_name=database_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
@@ -1591,36 +1991,35 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_export.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/export"
     }
 
-    async def _force_unlink_initial(  # pylint: disable=inconsistent-return-statements
+    def _force_unlink_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.ForceUnlinkParameters, IO],
         **kwargs: Any
     ) -> None:
@@ -1631,15 +2030,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
@@ -1661,16 +2060,17 @@
             template_url=self._force_unlink_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1680,24 +2080,24 @@
             return cls(pipeline_response, None, {})
 
     _force_unlink_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/forceUnlink"
     }
 
     @overload
-    async def begin_force_unlink(
+    def begin_force_unlink(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: _models.ForceUnlinkParameters,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Forcibly removes the link to the specified database resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1706,36 +2106,36 @@
         :param parameters: Information identifying the database to be unlinked. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.ForceUnlinkParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_force_unlink(
+    def begin_force_unlink(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Forcibly removes the link to the specified database resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
@@ -1744,74 +2144,74 @@
         :param parameters: Information identifying the database to be unlinked. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_force_unlink(
+    @distributed_trace
+    def begin_force_unlink(
         self,
         resource_group_name: str,
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.ForceUnlinkParameters, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    ) -> LROPoller[None]:
         """Forcibly removes the link to the specified database resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the RedisEnterprise cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database. Required.
         :type database_name: str
-        :param parameters: Information identifying the database to be unlinked. Is either a model type
-         or a IO type. Required.
+        :param parameters: Information identifying the database to be unlinked. Is either a
+         ForceUnlinkParameters type or a IO type. Required.
         :type parameters: ~azure.mgmt.redisenterprise.models.ForceUnlinkParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-01-01"] = kwargs.pop(
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
             "api_version", _params.pop("api-version", self._config.api_version)
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._force_unlink_initial(  # type: ignore
+            raw_result = self._force_unlink_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
                 database_name=database_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
@@ -1822,27 +2222,264 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_force_unlink.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/forceUnlink"
     }
+
+    def _flush_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        database_name: str,
+        parameters: Union[_models.FlushParameters, IO],
+        **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(parameters, (IO, bytes)):
+            _content = parameters
+        else:
+            _json = self._serialize.body(parameters, "FlushParameters")
+
+        request = build_flush_request(
+            resource_group_name=resource_group_name,
+            cluster_name=cluster_name,
+            database_name=database_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._flush_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200, 202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _flush_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/flush"
+    }
+
+    @overload
+    def begin_flush(
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        database_name: str,
+        parameters: _models.FlushParameters,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Flushes all the keys in this database and also from its linked databases.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param cluster_name: The name of the RedisEnterprise cluster. Required.
+        :type cluster_name: str
+        :param database_name: The name of the database. Required.
+        :type database_name: str
+        :param parameters: Information identifying the databases to be flushed. Required.
+        :type parameters: ~azure.mgmt.redisenterprise.models.FlushParameters
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    def begin_flush(
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        database_name: str,
+        parameters: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Flushes all the keys in this database and also from its linked databases.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param cluster_name: The name of the RedisEnterprise cluster. Required.
+        :type cluster_name: str
+        :param database_name: The name of the database. Required.
+        :type database_name: str
+        :param parameters: Information identifying the databases to be flushed. Required.
+        :type parameters: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace
+    def begin_flush(
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        database_name: str,
+        parameters: Union[_models.FlushParameters, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Flushes all the keys in this database and also from its linked databases.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param cluster_name: The name of the RedisEnterprise cluster. Required.
+        :type cluster_name: str
+        :param database_name: The name of the database. Required.
+        :type database_name: str
+        :param parameters: Information identifying the databases to be flushed. Is either a
+         FlushParameters type or a IO type. Required.
+        :type parameters: ~azure.mgmt.redisenterprise.models.FlushParameters or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: Literal["2023-03-01-preview"] = kwargs.pop(
+            "api_version", _params.pop("api-version", self._config.api_version)
+        )
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = self._flush_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                cluster_name=cluster_name,
+                database_name=database_name,
+                parameters=parameters,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(PollingMethod, NoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return LROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_flush.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}/databases/{databaseName}/flush"
+    }
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/SOURCES.txt` & `azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -22,25 +22,27 @@
 azure/mgmt/redisenterprise/aio/operations/_databases_operations.py
 azure/mgmt/redisenterprise/aio/operations/_operations.py
 azure/mgmt/redisenterprise/aio/operations/_operations_status_operations.py
 azure/mgmt/redisenterprise/aio/operations/_patch.py
 azure/mgmt/redisenterprise/aio/operations/_private_endpoint_connections_operations.py
 azure/mgmt/redisenterprise/aio/operations/_private_link_resources_operations.py
 azure/mgmt/redisenterprise/aio/operations/_redis_enterprise_operations.py
+azure/mgmt/redisenterprise/aio/operations/_skus_operations.py
 azure/mgmt/redisenterprise/models/__init__.py
 azure/mgmt/redisenterprise/models/_models_py3.py
 azure/mgmt/redisenterprise/models/_patch.py
 azure/mgmt/redisenterprise/models/_redis_enterprise_management_client_enums.py
 azure/mgmt/redisenterprise/operations/__init__.py
 azure/mgmt/redisenterprise/operations/_databases_operations.py
 azure/mgmt/redisenterprise/operations/_operations.py
 azure/mgmt/redisenterprise/operations/_operations_status_operations.py
 azure/mgmt/redisenterprise/operations/_patch.py
 azure/mgmt/redisenterprise/operations/_private_endpoint_connections_operations.py
 azure/mgmt/redisenterprise/operations/_private_link_resources_operations.py
 azure/mgmt/redisenterprise/operations/_redis_enterprise_operations.py
+azure/mgmt/redisenterprise/operations/_skus_operations.py
 azure_mgmt_redisenterprise.egg-info/PKG-INFO
 azure_mgmt_redisenterprise.egg-info/SOURCES.txt
 azure_mgmt_redisenterprise.egg-info/dependency_links.txt
 azure_mgmt_redisenterprise.egg-info/not-zip-safe
 azure_mgmt_redisenterprise.egg-info/requires.txt
 azure_mgmt_redisenterprise.egg-info/top_level.txt
```

## Comparing `azure-mgmt-redisenterprise-2.1.0b1/azure_mgmt_redisenterprise.egg-info/PKG-INFO` & `azure-mgmt-redisenterprise-2.1.0b2/azure_mgmt_redisenterprise.egg-info/PKG-INFO`

 * *Files 27% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-redisenterprise
-Version: 2.1.0b1
+Version: 2.1.0b2
 Summary: Microsoft Azure Redis Enterprise Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 4 - Beta
@@ -27,36 +27,90 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-# Usage
+## Getting started
 
+### Prerequisites
 
-To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
- 
-For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/)
-Code samples for this package can be found at [Redis Enterprise Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
-Additional code samples for different Azure services are available at [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+- Python 3.7+ is required to use this package.
+- [Azure subscription](https://azure.microsoft.com/free/)
 
+### Install the package
 
-# Provide Feedback
+```bash
+pip install azure-mgmt-redisenterprise
+pip install azure-identity
+```
+
+### Authentication
+
+By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
+
+- `AZURE_CLIENT_ID` for Azure client ID.
+- `AZURE_TENANT_ID` for Azure tenant ID.
+- `AZURE_CLIENT_SECRET` for Azure client secret.
+
+In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
+
+With above configuration, client can be authenticated by following code:
+
+```python
+from azure.identity import DefaultAzureCredential
+from azure.mgmt.redisenterprise import RedisEnterpriseManagementClient
+import os
+
+sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
+client = RedisEnterpriseManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
+```
+
+## Examples
+
+Code samples for this package can be found at:
+- [Search Redis Enterprise Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+
+
+## Troubleshooting
+
+## Next steps
+
+## Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-redisenterprise%2FREADME.png)
 
 
 # Release History
 
+## 2.1.0b2 (2023-04-20)
+
+### Features Added
+
+  - Added operation DatabasesOperations.begin_flush
+  - Added operation group SkusOperations
+  - Model Cluster has a new parameter encryption
+  - Model Cluster has a new parameter identity
+  - Model Cluster has a new parameter system_data
+  - Model ClusterUpdate has a new parameter encryption
+  - Model ClusterUpdate has a new parameter identity
+  - Model Database has a new parameter system_data
+  - Model PrivateEndpointConnection has a new parameter system_data
+  - Model PrivateLinkResource has a new parameter system_data
+  - Model ProxyResource has a new parameter system_data
+  - Model Resource has a new parameter system_data
+  - Model TrackedResource has a new parameter system_data
+
 ## 2.1.0b1 (2022-11-22)
 
 ### Other Changes
 
   - Added generated samples in github repo
   - Drop support for python<3.7.0
```

